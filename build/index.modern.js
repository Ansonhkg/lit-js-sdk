import e from"jszip";import"tweetnacl";import"tweetnacl-util";import t from"web3";import n from"@metamask/detect-provider";import a from"firebase/app";import"firebase/functions";import r from"multihashing";import s from"cids";import o from"libp2p";import i from"libp2p-websockets";import p from"libp2p-webrtc-direct";import{NOISE as d}from"libp2p-noise";import l from"libp2p-mplex";import c from"libp2p-kad-dht";import y from"peer-id";import"multiaddr";import u from"libp2p-bootstrap";import m from"it-pipe";import"it-length-prefixed";import"it-pushable";import g from"secrets.js-grempe";import b from"uint8arrays/from-string";import f from"uint8arrays/to-string";import w from"it-all";const h={name:"AES-CBC",length:256},T={};async function S(t,n){const a=await async function(e){return await crypto.subtle.importKey("jwk",JSON.parse(e),h,!0,["encrypt","decrypt"])}(n),r=await async function(e,t){const n=await e.slice(0,16).arrayBuffer(),a=await e.slice(16).arrayBuffer();return await crypto.subtle.decrypt({name:"AES-CBC",iv:n},t,a)}(t,a),s=new e;return(await s.loadAsync(r)).files}async function E(e){const t=await e.generateAsync({type:"blob"}),n=await t.arrayBuffer();console.log("blob",t);const a=await async function(){return await crypto.subtle.generateKey(h,!0,["encrypt","decrypt"])}(),r=await async function(e,t){const n=window.crypto.getRandomValues(new Uint8Array(16)),a=await crypto.subtle.encrypt({name:"AES-CBC",iv:n},e,t);return new Blob([n,new Uint8Array(a)],{type:"application/octet-stream"})}(a,n),s=await crypto.subtle.exportKey("jwk",a);return console.log("exportedSymmKey",s),{symmetricKey:s,encryptedZip:r}}async function k(e){if(T[e])return T[e];const t=await fetch("https://unpkg.com/"+e);if(!t.ok)throw console.log("error with response: ",t),Error(t.statusText);const n=await t.blob(),a=await(r=n,new Promise((e,t)=>{const n=new FileReader;n.onloadend=()=>{e(n.result)},n.readAsDataURL(r)}));var r;return T[e]=a,a}a.initializeApp({apiKey:"AIzaSyDa3JnwzrjfY5DcPz4GtywdUUUY3zqWo0w",authDomain:"mintlit.firebaseapp.com",projectId:"mintlit",storageBucket:"mintlit.appspot.com",messagingSenderId:"1044454922569",appId:"1:1044454922569:web:a3cf1d5637f18413f66298",measurementId:"G-NC19HWVQPT"});var A=[{inputs:[],stateMutability:"nonpayable",type:"constructor"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"userAddress",type:"address"},{indexed:!1,internalType:"address payable",name:"relayerAddress",type:"address"},{indexed:!1,internalType:"bytes",name:"functionSignature",type:"bytes"}],name:"MetaTransactionExecuted",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256[]",name:"ids",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"values",type:"uint256[]"}],name:"TransferBatch",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"id",type:"uint256"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"TransferSingle",type:"event"},{anonymous:!1,inputs:[{indexed:!1,internalType:"string",name:"value",type:"string"},{indexed:!0,internalType:"uint256",name:"id",type:"uint256"}],name:"URI",type:"event"},{inputs:[],name:"ERC712_VERSION",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"id",type:"uint256"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"ids",type:"uint256[]"}],name:"balanceOfBatch",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"address",name:"userAddress",type:"address"},{internalType:"bytes",name:"functionSignature",type:"bytes"},{internalType:"bytes32",name:"sigR",type:"bytes32"},{internalType:"bytes32",name:"sigS",type:"bytes32"},{internalType:"uint8",name:"sigV",type:"uint8"}],name:"executeMetaTransaction",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function",payable:!0},{inputs:[],name:"getChainId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",constant:!0},{inputs:[],name:"getDomainSeperator",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"address",name:"user",type:"address"}],name:"getNonce",outputs:[{internalType:"uint256",name:"nonce",type:"uint256"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeBatchTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",constant:!0},{inputs:[],name:"tokenIds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"uri",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"uint256",name:"quantity",type:"uint256"}],name:"mint",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"address",name:"_operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"isOperator",type:"bool"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"bool",name:"enabled",type:"bool"}],name:"setOpenseaProxyEnabled",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"string",name:"uri",type:"string"}],name:"setURI",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[],name:"getAdmin",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",constant:!0}];const R=require("protons")("\nmessage Request {\n  enum Type {\n    GET_KEY_FRAGMENT = 0;\n    STORE_KEY_FRAGMENT = 1;\n  }\n  required Type type = 1;\n  optional GetKeyFragment getKeyFragment = 2;\n  optional StoreKeyFragment storeKeyFragment = 3;\n  optional bytes authSig = 4;\n}\nmessage Response {\n  enum Type {\n    GET_KEY_FRAGMENT_RESPONSE = 0;\n    STORE_KEY_FRAGMENT_RESPONSE = 1;\n  }\n  required Type type = 1;\n  optional GetKeyFragmentResponse getKeyFragmentResponse = 2;\n  optional StoreKeyFragmentResponse storeKeyFragmentResponse = 3;\n}\nmessage GetKeyFragment {\n  required bytes keyId = 1;\n}\nmessage GetKeyFragmentResponse {\n  enum Result {\n    SUCCESS = 0;\n    NOT_FOUND = 1;\n    ERROR = 2;\n  }\n  required Result result = 1;\n  optional bytes keyId = 2;\n  optional bytes fragmentValue = 3;\n}\nmessage StoreKeyFragment {\n  required bytes tokenAddress = 1;\n  required bytes tokenId = 2;\n  required bytes chain = 3;\n  required bytes fragmentValue = 4;\n}\nmessage StoreKeyFragmentResponse {\n  enum Result {\n    SUCCESS = 0;\n    AUTH_FAILURE = 1;\n    ERROR = 2;\n  }\n  required Result result = 1;\n  optional bytes errorMessage = 2;\n}\n"),I={polygon:{contractAddress:"0xb9A323711528D0c5a70df790929f4739f1cDd7fD",chainId:137},ethereum:{contractAddress:"0x55485885e82E25446DEC314Ccb810Bda06B9e01B",chainId:1}};async function v(){if(void 0===window.ethereum)throw new Error({errorCode:"no_wallet",message:"No web3 wallet was found"});const e=await n(),a=(await e.request({method:"eth_requestAccounts"}))[0].toLowerCase();return{web3:new t(e),account:a}}async function F(){let e=localStorage.getItem("lit-auth-signature");e||(await K(),e=localStorage.getItem("lit-auth-signature")),e=JSON.parse(e);const{account:t}=await v();return t!==e.address&&(await K(),e=localStorage.getItem("lit-auth-signature"),e=JSON.parse(e)),e}async function K(){const e=(new Date).toISOString(),t="I am creating an account to use LITs at {{timestamp}}".replace("{{timestamp}}",e),n=await async function({body:e}){const{web3:t,account:n}=await v();console.log("signing with ",n);const a=await t.eth.personal.sign(e,n),r=t.eth.accounts.recover(e,a).toLowerCase();if(console.log("Signature: ",a),console.log("recovered address: ",r),r!==n){const e=`ruh roh, the user signed with a different address (${r}) then they're using with web3 (${n}).  this will lead to confusion.`;throw console.error(e),alert("something seems to be wrong with your wallets message signing.  maybe restart your browser or your wallet.  your recovered sig address does not match your web3 account address"),new Error(e)}return{signature:a,address:r}}({body:t});localStorage.setItem("lit-auth-signature",JSON.stringify({sig:n.signature,derivedVia:"web3.eth.personal.sign",signedMessage:t,address:n.address}))}const M=({tokenAddress:e,tokenId:t,chain:n})=>{const a=e.toLowerCase(),o=t.toString(16).padStart(64,"0"),i=r(Buffer.from(`${a}|${o}|${n}`),"sha2-256");return new s(i).toString()},{Request:C,Response:x,StoreKeyFragmentResponse:N,GetKeyFragmentResponse:_}=R,B={zipAndEncryptString:async function(t){const n=new e;return n.file("string.txt",t),E(n)},zipAndEncryptFiles:async function(t){const n=new e;for(let e=0;e<t.length;e++)n.folder("encryptedAssets").file(t[e].name,t[e]);return E(n)},encryptZip:E,decryptZip:S,connectWeb3:v,checkAndSignAuthMessage:F,createHtmlLIT:async function({title:e,htmlBody:t,css:n,encryptedSymmetricKey:a,encryptedZipDataUrl:r,npmPackages:s=[]}){s.push("lit-js-sdk");let o="";for(let e=0;e<s.length;e++)o+=`<script src="${await k(s[e])}"><\/script>\n`;return`\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>${e}</title>\n    <style id="jss-server-side">${n}</style>\n    ${o}\n    <script>\n      var encryptedSymmetricKey = ${a}\n      var encryptedZipDataUrl = "${r}"\n      var locked = true\n    <\/script>\n  </head>\n  <body>\n    <div id="root">${t}</div>\n    <script>\n      const unlockButton = document.getElementById('unlockButton')\n      unlockButton.onclick = function() {\n        LitJsSdk.default.toggleLock()\n      }\n    <\/script>\n  </body>\n</html>\n  `},mintLIT:async function({chain:e,quantity:t}){console.log(`minting ${t} tokens on ${e}`);const n=await F(),{web3:a,account:r}=await v();if(await a.eth.getChainId()!==I[e].chainId)return{errorCode:"wrong_chain"};const s=I[e].contractAddress,o=new a.eth.Contract(A,s);console.log("sending to chain...");try{const e=await o.methods.mint(t).send({from:r});return console.log("txReceipt: ",e),{txHash:e.transactionHash,tokenId:e.events.TransferSingle.returnValues.id,tokenAddress:s,mintingAddress:r,authSig:n}}catch(e){return console.log(e),4001===e.code?(console.log("User rejected request"),{errorCode:"user_rejected_request"}):(console.error(e),{errorCode:"unknown_error"})}},toggleLock:async function(){const e=document.getElementById("mediaGridHolder"),t=document.getElementById("lockedHeader");if(window.locked){window.publicContent=e.innerHTML;const n=await(await fetch(window.encryptedZipDataUrl)).blob(),a=await S(n,JSON.stringify(window.encryptedSymmetricKey)),r=await a["string.txt"].async("text");e.innerHTML=r,t.innerText="UNLOCKED",window.locked=!1}else e.innerHTML=window.publicContent,t.innerText="LOCKED",window.locked=!0},LIT_CHAINS:I,LitNodeClient:class{constructor(e){this.libp2p=null,this.connectedNodes=new Set}async saveEncryptionKey({tokenAddress:e,tokenId:t,symmetricKey:n,authSig:a,chain:r}){const s=Array.from(this.connectedNodes),o=s.length,i=Math.floor(o/2),p=Buffer.from(n).toString("hex");console.debug(`splitting up into ${o} shares with a threshold of ${i}`);const d=g.share(p,o,i);if(d.length!==s.length)throw new Error(`kFrags.length (${d.length}) !== nodes.length (${s.length})`);const l=[],c=e.toLowerCase();for(let e=0;e<s.length;e++)console.debug(`storing kFrag in node ${e+1} of ${s.length}`),l.push(this.storeDataWithNode({peerId:s[e],tokenAddress:c,tokenId:t,val:d[e],authSig:a,chain:r}));return await Promise.all(l),console.log("all stored"),{success:!0}}async getEncryptionKeyFragments({tokenAddress:e,tokenId:t,authSig:n,chain:a}){const r=M({tokenAddress:e,tokenId:t,chain:a}),o=new s(r),i=await w(this.libp2p.contentRouting.findProviders(o,{timeout:3e3}));console.log(`Found ${i.length} providers`);const p=[];for(let e=0;e<i.length;e++)p.push(this.getDataFromNode({peerId:i[e].id.toB58String(),authSig:n,keyId:r,chain:a}));return await Promise.all(p)}async storeDataWithNode({peerId:e,tokenAddress:t,tokenId:n,val:a,authSig:r,chain:s}){console.debug(`storing data with node ${e} with tokenAddress ${t} and tokenId ${n}`);const o=C.encode({type:C.Type.STORE_KEY_FRAGMENT,storeKeyFragment:{tokenAddress:b(t),tokenId:b(n.toString()),chain:b(s),fragmentValue:b(a)},authSig:b(JSON.stringify(r))});return await this.sendCommandToPeer({peerId:e,data:o})}async getDataFromNode({peerId:e,keyId:t,authSig:n}){const a=C.encode({type:C.Type.GET_KEY_FRAGMENT,getKeyFragment:{keyId:b(t)},authSig:b(n.sig)});return await this.sendCommandToPeer({peerId:e,data:a})}async sendCommandToPeer({peerId:e,data:t}){const n=this.libp2p.connectionManager.get(y.createFromB58String(e)),{stream:a}=await n.newStream(["/lit/1.0.0"]);let r=null;return await m([t],a,async function(e){const{value:t}=await e.next(),n=x.decode(t.slice());n.type===x.Type.STORE_KEY_FRAGMENT_RESPONSE?n.storeKeyFragmentResponse.result===N.Result.SUCCESS?(console.log("success storing key fragment"),r=!0):(console.log("error storing key fragment: "),console.log(f(n.storeKeyFragmentResponse.errorMessage)),r=!1):n.type===x.Type.GET_KEY_FRAGMENT_RESPONSE?n.getKeyFragmentResponse.result===_.Result.SUCCESS?(console.log("success getting key fragment"),r=f(n.getKeyFragmentResponse.fragmentValue)):n.getKeyFragmentResponse.result===_.Result.NOT_FOUND?(console.log("key fragment not found"),r=!1):(console.log("unknown error getting key fragment"),r=!1):console.log("unknown response type")}),r}async connect(){var e=this;this.libp2p=await o.create({modules:{transport:[i,p],connEncryption:[d],streamMuxer:[l],dht:c,peerDiscovery:[u]},config:{dht:{enabled:!0},peerDiscovery:{[u.tag]:{enabled:!0,list:["/ip4/127.0.0.1/tcp/9090/http/p2p-webrtc-direct/p2p/12D3KooWK1KtaAV5rWjbAmZcd62VYSmEz1k81jzr87JAcSS7rKdQ"]}}}}),this.libp2p.on("peer:discovery",e=>{console.debug(`Found peer ${e.toB58String()}`)}),this.libp2p.connectionManager.on("peer:connect",async function(t){const n=t.remotePeer.toB58String();console.debug(`Connected to ${n}`),e.connectedNodes.has(n)||e.connectedNodes.add(n)}),this.libp2p.connectionManager.on("peer:disconnect",e=>{const t=e.remotePeer.toB58String();console.debug(`Disconnected from ${t}`),this.connectedNodes.delete(t)}),await this.libp2p.start(),console.debug(`libp2p id is ${this.libp2p.peerId.toB58String()}`),this.libp2p.multiaddrs.forEach(e=>console.debug(`${e.toString()}/p2p/${this.libp2p.peerId.toB58String()}`)),window.libp2p=this.libp2p,window.PeerId=y}},getUploadUrl:async function(){const e=a.functions().httpsCallable("getUploadUrl"),t=await e();return console.log(t),t.data},createTokenMetadata:async function(e){const t=a.functions().httpsCallable("createTokenMetadata"),n=await t(e);return console.log(n),n.data},protobufs:R,kFragKey:M};export default B;
//# sourceMappingURL=index.modern.js.map
