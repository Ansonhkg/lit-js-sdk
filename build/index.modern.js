import e from"jszip";import t from"tweetnacl";import n from"tweetnacl-util";import a from"web3";import i from"@metamask/detect-provider";import r from"firebase/app";import"firebase/functions";import o from"libp2p";import s from"libp2p-websockets";import c from"libp2p-webrtc-direct";import{NOISE as p}from"libp2p-noise";import d from"libp2p-mplex";import y from"libp2p-kad-dht";import"peer-id";import"multiaddr";import l from"libp2p-bootstrap";import u from"it-pipe";import m from"it-length-prefixed";import b from"multihashing";import f from"cids";import g from"it-pushable";import w from"secrets.js-grempe";const h={name:"AES-CBC",length:256};r.initializeApp({apiKey:"AIzaSyDa3JnwzrjfY5DcPz4GtywdUUUY3zqWo0w",authDomain:"mintlit.firebaseapp.com",projectId:"mintlit",storageBucket:"mintlit.appspot.com",messagingSenderId:"1044454922569",appId:"1:1044454922569:web:a3cf1d5637f18413f66298",measurementId:"G-NC19HWVQPT"});var T=[{inputs:[],stateMutability:"nonpayable",type:"constructor"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"userAddress",type:"address"},{indexed:!1,internalType:"address payable",name:"relayerAddress",type:"address"},{indexed:!1,internalType:"bytes",name:"functionSignature",type:"bytes"}],name:"MetaTransactionExecuted",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256[]",name:"ids",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"values",type:"uint256[]"}],name:"TransferBatch",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"id",type:"uint256"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"TransferSingle",type:"event"},{anonymous:!1,inputs:[{indexed:!1,internalType:"string",name:"value",type:"string"},{indexed:!0,internalType:"uint256",name:"id",type:"uint256"}],name:"URI",type:"event"},{inputs:[],name:"ERC712_VERSION",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"id",type:"uint256"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"ids",type:"uint256[]"}],name:"balanceOfBatch",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"address",name:"userAddress",type:"address"},{internalType:"bytes",name:"functionSignature",type:"bytes"},{internalType:"bytes32",name:"sigR",type:"bytes32"},{internalType:"bytes32",name:"sigS",type:"bytes32"},{internalType:"uint8",name:"sigV",type:"uint8"}],name:"executeMetaTransaction",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function",payable:!0},{inputs:[],name:"getChainId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",constant:!0},{inputs:[],name:"getDomainSeperator",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"address",name:"user",type:"address"}],name:"getNonce",outputs:[{internalType:"uint256",name:"nonce",type:"uint256"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeBatchTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",constant:!0},{inputs:[],name:"tokenIds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"uri",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"uint256",name:"quantity",type:"uint256"}],name:"mint",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"address",name:"_operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"isOperator",type:"bool"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"bool",name:"enabled",type:"bool"}],name:"setOpenseaProxyEnabled",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"string",name:"uri",type:"string"}],name:"setURI",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[],name:"getAdmin",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",constant:!0}];const v={polygon:{contractAddress:"0xb9A323711528D0c5a70df790929f4739f1cDd7fD",chainId:137},ethereum:{contractAddress:"0x55485885e82E25446DEC314Ccb810Bda06B9e01B",chainId:1}};async function k(){let e=localStorage.getItem("lit-keypair");e||(await K(),e=localStorage.getItem("lit-keypair")),e=JSON.parse(e);const{account:t}=await S();return t!==e.address&&(await K(),e=localStorage.getItem("lit-keypair"),e=JSON.parse(e)),e}async function S(){if(void 0===window.ethereum)throw new Error({errorCode:"no_wallet",message:"No web3 wallet was found"});const e=await i(),t=(await e.request({method:"eth_requestAccounts"}))[0];return{web3:new a(e),account:t}}async function x({body:e}){const{web3:t,account:n}=await S();console.log("signing with ",n);const a=await t.eth.personal.sign(e,n),i=t.eth.accounts.recover(e,a);if(console.log("Signature: ",a),console.log("recovered address: ",i),i!==n){const e=`ruh roh, the user signed with a different address (${i}) then they're using with web3 (${n}).  this will lead to confusion.`;throw console.error(e),alert("something seems to be wrong with your wallets message signing.  maybe restart your browser or your wallet.  your recovered sig address does not match your web3 account address"),new Error(e)}return{signature:a,address:i}}async function K(){let e={};const{error:a,publicKey:i}=await async function(){try{const{account:e}=await S();return{publicKey:await ethereum.request({method:"eth_getEncryptionPublicKey",params:[e]})}}catch(e){return console.log(e),4001===e.code?(console.log("We can't encrypt anything without the key."),e("You must accept the metamask request to derive your public encryption key")):console.error(e),{error:e}}}();if(a){const{publicKey:a,secretKey:i}=await async function(){const{signature:e}=await x({body:"I am creating an account to mint a LIT"});console.log("Signed message: "+e);const a=Buffer.from(e.substring(2),"hex"),i=await crypto.subtle.digest("SHA-256",a),r=new Uint8Array(i),{publicKey:o,secretKey:s}=t.box.keyPair.fromSecretKey(r);return{publicKey:n.encodeBase64(o),secretKey:n.encodeBase64(s)}}();e={publicKey:a,secretKey:i,derivedVia:"web3.eth.personal.sign",signedMessage:"I am creating an account to mint a LIT"}}else e={publicKey:i,derivedVia:"eth_getEncryptionPublicKey"};const{account:o}=await S();e.address=o,console.log("public key: "+e.publicKey);const s=JSON.stringify(e);localStorage.setItem("lit-keypair",s);const{pubkey:c,errorCode:p}=await async function(e){const t=r.functions().httpsCallable("getPublicKey"),n=await t(e);return console.log(n),n.data}({address:o});if("not_found"===p||c!==e.publicKey){const t=`I am saving my public key so that others can send me LITs.  It is ${c}`,n=await x({body:t});await async function(e){const t=r.functions().httpsCallable("savePublicKey"),n=await t(e);return console.log(n),n.data}({sig:n.signature,msg:t,pubkey:e.publicKey})}}const B={};async function I(a,i){const r=await k();console.log("Got keypair out of localstorage: "+r);const o=r.secretKey;let s=await async function(e){const{account:t}=await S();try{return ethereum.request({method:"eth_decrypt",params:[e,t]})}catch(e){return console.log(e),!1}}(i);s||(console.log("probably not metamask"),s=function(e,a){switch(e.version){case"x25519-xsalsa20-poly1305":{const i=n.decodeBase64(a),r=n.decodeBase64(e.nonce),o=n.decodeBase64(e.ciphertext),s=n.decodeBase64(e.ephemPublicKey),c=t.box.open(o,r,s,i);let p;try{p=n.encodeUTF8(c)}catch(e){throw new Error("Decryption failed.")}if(p)return p;throw new Error("Decryption failed.")}default:throw new Error("Encryption type/version not supported.")}}(i,o)),console.log("decrypted",s);const c=await async function(e){return await crypto.subtle.importKey("jwk",JSON.parse(e),h,!0,["encrypt","decrypt"])}(s),p=await async function(e,t){const n=await e.slice(0,16).arrayBuffer(),a=await e.slice(16).arrayBuffer();return await crypto.subtle.decrypt({name:"AES-CBC",iv:n},t,a)}(a,c),d=new e;return(await d.loadAsync(p)).files}async function A(e){const a=await e.generateAsync({type:"blob"}),i=await a.arrayBuffer();console.log("blob",a);const r=await async function(){return await crypto.subtle.generateKey(h,!0,["encrypt","decrypt"])}(),o=await async function(e,t){const n=window.crypto.getRandomValues(new Uint8Array(16)),a=await crypto.subtle.encrypt({name:"AES-CBC",iv:n},e,t);return new Blob([n,new Uint8Array(a)],{type:"application/octet-stream"})}(r,i),s=await crypto.subtle.exportKey("jwk",r);console.log("exportedSymmKey",s);const c=function(e,a,i){{const i=t.box.keyPair();let r;try{r=n.decodeBase64(e)}catch(e){throw new Error("Bad public key")}const o=n.decodeUTF8(a),s=t.randomBytes(t.box.nonceLength),c=t.box(o,s,r,i.secretKey);return{version:"x25519-xsalsa20-poly1305",nonce:n.encodeBase64(s),ephemPublicKey:n.encodeBase64(i.publicKey),ciphertext:n.encodeBase64(c)}}}((await k()).publicKey,JSON.stringify(s));return{encryptedSymmetricKey:JSON.stringify(c),encryptedZip:o}}async function E(e){if(B[e])return B[e];const t=await fetch("https://unpkg.com/"+e);if(!t.ok)throw console.log("error with response: ",t),Error(t.statusText);const n=await t.blob(),a=await(i=n,new Promise((e,t)=>{const n=new FileReader;n.onloadend=()=>{e(n.result)},n.readAsDataURL(i)}));var i;return B[e]=a,a}const M={zipAndEncryptString:async function(t){const n=new e;return n.file("string.txt",t),A(n)},zipAndEncryptFiles:async function(t){const n=new e;for(let e=0;e<t.length;e++)n.folder("encryptedAssets").file(t[e].name,t[e]);return A(n)},encryptZip:A,decryptZip:I,checkAndDeriveKeypair:k,connectWeb3:S,createHtmlLIT:async function({title:e,htmlBody:t,css:n,encryptedSymmetricKey:a,encryptedZipDataUrl:i,npmPackages:r=[]}){r.push("lit-js-sdk");let o="";for(let e=0;e<r.length;e++)o+=`<script src="${await E(r[e])}"><\/script>\n`;return`\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>${e}</title>\n    <style id="jss-server-side">${n}</style>\n    ${o}\n    <script>\n      var encryptedSymmetricKey = ${a}\n      var encryptedZipDataUrl = "${i}"\n      var locked = true\n    <\/script>\n  </head>\n  <body>\n    <div id="root">${t}</div>\n    <script>\n      const unlockButton = document.getElementById('unlockButton')\n      unlockButton.onclick = function() {\n        LitJsSdk.default.toggleLock()\n      }\n    <\/script>\n  </body>\n</html>\n  `},mintLIT:async function({chain:e,quantity:t}){console.log(`minting ${t} tokens on ${e}`),await k();const{web3:n,account:a}=await S();if(await n.eth.getChainId()!==v[e].chainId)return{errorCode:"wrong_chain"};const i=v[e].contractAddress,r=new n.eth.Contract(T,i);console.log("sending to chain...");try{const e=await r.methods.mint(t).send({from:a});return console.log("txReceipt: ",e),{txHash:e.transactionHash,tokenId:e.events.TransferSingle.returnValues.id,tokenAddress:i,mintingAddress:a}}catch(e){return console.log(e),4001===e.code?(console.log("User rejected request"),{errorCode:"user_rejected_request"}):(console.error(e),{errorCode:"unknown_error"})}},toggleLock:async function(){const e=document.getElementById("mediaGridHolder"),t=document.getElementById("lockedHeader");if(window.locked){window.publicContent=e.innerHTML;const n=await(await fetch(window.encryptedZipDataUrl)).blob(),a=await I(n,JSON.stringify(window.encryptedSymmetricKey)),i=await a["string.txt"].async("text");e.innerHTML=i,t.innerText="UNLOCKED",window.locked=!1}else e.innerHTML=window.publicContent,t.innerText="LOCKED",window.locked=!0},LIT_CHAINS:v,LitNodeClient:class{constructor(e){this.libp2p=null,this.connectedNodes={}}async saveEncryptionKey({contractAddress:e,tokenId:t,symmetricKey:n}){const a=Object.keys(this.connectedNodes),i=a.length,r=Math.floor(i/2),o=Buffer.from(n,"base64").toString("hex"),s=w.share(o,i,r);if(s.length!==a.length)throw new Error(`kFrags.length (${s.length}) !== nodeKeys.length (${a.length})`);const c=[],p=e.toLowerCase(),d=t.toString(16).padStart(64,"0");for(let e=0;e<a.length;e++){const t=`${p}|${d}|${e}`;console.debug(`storing kFrag with key ${t} in node ${e+1} of ${a.length}`),c.push(this.storeData({peerId:a[e],key:t,val:s[e]}))}return await Promise.all(c),console.log("all stored"),{success:!0}}async storeData({peerId:e,key:t,val:n}){const a=b(Buffer.from(t),"sha2-256"),i=new f(a),r=JSON.stringify({cmd:"set",key:i.toString(),val:n});this.connectedNodes[e].send(r)}dataReceived({peerId:e,msg:t}){console.log(`dataReceived from ${e.toB58String()}: ${t}`)}async connect(){var e=this;this.libp2p=await o.create({modules:{transport:[s,c],connEncryption:[p],streamMuxer:[d],dht:y,peerDiscovery:[l]},config:{dht:{enabled:!0},peerDiscovery:{[l.tag]:{enabled:!0,list:["/ip4/127.0.0.1/tcp/9090/http/p2p-webrtc-direct/p2p/12D3KooWK1KtaAV5rWjbAmZcd62VYSmEz1k81jzr87JAcSS7rKdQ"]}}}}),this.libp2p.on("peer:discovery",e=>{console.debug(`Found peer ${e.toB58String()}`)}),this.libp2p.connectionManager.on("peer:connect",async function(t){console.debug(`Connected to ${t.remotePeer.toB58String()}`);const{stream:n}=await t.newStream(["/lit/1.0.0"]),a=g();u(a,m.encode(),n.sink),e.connectedNodes[t.remotePeer.toB58String()]={send:a.push}}),this.libp2p.connectionManager.on("peer:disconnect",e=>{console.debug(`Disconnected from ${e.remotePeer.toB58String()}`)}),await this.libp2p.start(),console.debug(`libp2p id is ${this.libp2p.peerId.toB58String()}`),this.libp2p.multiaddrs.forEach(e=>console.debug(`${e.toString()}/p2p/${this.libp2p.peerId.toB58String()}`)),window.libp2p=this.libp2p}}};export default M;
//# sourceMappingURL=index.modern.js.map
