import e from"jszip";import t from"tweetnacl";import n from"tweetnacl-util";import a from"web3";import r from"@metamask/detect-provider";import o from"firebase/app";import"firebase/functions";import s from"libp2p";import i from"libp2p-websockets";import p from"libp2p-webrtc-direct";import{NOISE as c}from"libp2p-noise";import y from"libp2p-mplex";import l from"libp2p-kad-dht";import d from"peer-id";import"multiaddr";import u from"libp2p-bootstrap";import m from"it-pipe";import"it-length-prefixed";import g from"multihashing";import b from"cids";import"it-pushable";import f from"secrets.js-grempe";import w from"protons";import h from"uint8arrays/from-string";import T from"uint8arrays/to-string";const S={name:"AES-CBC",length:256};o.initializeApp({apiKey:"AIzaSyDa3JnwzrjfY5DcPz4GtywdUUUY3zqWo0w",authDomain:"mintlit.firebaseapp.com",projectId:"mintlit",storageBucket:"mintlit.appspot.com",messagingSenderId:"1044454922569",appId:"1:1044454922569:web:a3cf1d5637f18413f66298",measurementId:"G-NC19HWVQPT"});var K=[{inputs:[],stateMutability:"nonpayable",type:"constructor"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"userAddress",type:"address"},{indexed:!1,internalType:"address payable",name:"relayerAddress",type:"address"},{indexed:!1,internalType:"bytes",name:"functionSignature",type:"bytes"}],name:"MetaTransactionExecuted",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256[]",name:"ids",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"values",type:"uint256[]"}],name:"TransferBatch",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"id",type:"uint256"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"TransferSingle",type:"event"},{anonymous:!1,inputs:[{indexed:!1,internalType:"string",name:"value",type:"string"},{indexed:!0,internalType:"uint256",name:"id",type:"uint256"}],name:"URI",type:"event"},{inputs:[],name:"ERC712_VERSION",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"id",type:"uint256"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"ids",type:"uint256[]"}],name:"balanceOfBatch",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"address",name:"userAddress",type:"address"},{internalType:"bytes",name:"functionSignature",type:"bytes"},{internalType:"bytes32",name:"sigR",type:"bytes32"},{internalType:"bytes32",name:"sigS",type:"bytes32"},{internalType:"uint8",name:"sigV",type:"uint8"}],name:"executeMetaTransaction",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function",payable:!0},{inputs:[],name:"getChainId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",constant:!0},{inputs:[],name:"getDomainSeperator",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"address",name:"user",type:"address"}],name:"getNonce",outputs:[{internalType:"uint256",name:"nonce",type:"uint256"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeBatchTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",constant:!0},{inputs:[],name:"tokenIds",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"uri",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"uint256",name:"quantity",type:"uint256"}],name:"mint",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"address",name:"_operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"isOperator",type:"bool"}],stateMutability:"view",type:"function",constant:!0},{inputs:[{internalType:"bool",name:"enabled",type:"bool"}],name:"setOpenseaProxyEnabled",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"newAdmin",type:"address"}],name:"changeAdmin",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"string",name:"uri",type:"string"}],name:"setURI",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[],name:"getAdmin",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",constant:!0}];const E={polygon:{contractAddress:"0xb9A323711528D0c5a70df790929f4739f1cDd7fD",chainId:137},ethereum:{contractAddress:"0x55485885e82E25446DEC314Ccb810Bda06B9e01B",chainId:1}};async function k(){let e=localStorage.getItem("lit-keypair");e||(await x(),e=localStorage.getItem("lit-keypair")),e=JSON.parse(e);const{account:t}=await v();return t!==e.address&&(await x(),e=localStorage.getItem("lit-keypair"),e=JSON.parse(e)),e}async function v(){if(void 0===window.ethereum)throw new Error({errorCode:"no_wallet",message:"No web3 wallet was found"});const e=await r(),t=(await e.request({method:"eth_requestAccounts"}))[0];return{web3:new a(e),account:t}}async function R({body:e}){const{web3:t,account:n}=await v();console.log("signing with ",n);const a=await t.eth.personal.sign(e,n),r=t.eth.accounts.recover(e,a);if(console.log("Signature: ",a),console.log("recovered address: ",r),r!==n){const e=`ruh roh, the user signed with a different address (${r}) then they're using with web3 (${n}).  this will lead to confusion.`;throw console.error(e),alert("something seems to be wrong with your wallets message signing.  maybe restart your browser or your wallet.  your recovered sig address does not match your web3 account address"),new Error(e)}return{signature:a,address:r}}async function x(){let e={};const{error:a,publicKey:r}=await async function(){try{const{account:e}=await v();return{publicKey:await ethereum.request({method:"eth_getEncryptionPublicKey",params:[e]})}}catch(e){return console.log(e),4001===e.code?(console.log("We can't encrypt anything without the key."),e("You must accept the metamask request to derive your public encryption key")):console.error(e),{error:e}}}();if(a){const{publicKey:a,secretKey:r}=await async function(){const{signature:e}=await R({body:"I am creating an account to mint a LIT"});console.log("Signed message: "+e);const a=Buffer.from(e.substring(2),"hex"),r=await crypto.subtle.digest("SHA-256",a),o=new Uint8Array(r),{publicKey:s,secretKey:i}=t.box.keyPair.fromSecretKey(o);return{publicKey:n.encodeBase64(s),secretKey:n.encodeBase64(i)}}();e={publicKey:a,secretKey:r,derivedVia:"web3.eth.personal.sign",signedMessage:"I am creating an account to mint a LIT"}}else e={publicKey:r,derivedVia:"eth_getEncryptionPublicKey"};const{account:s}=await v();e.address=s,console.log("public key: "+e.publicKey);const i=JSON.stringify(e);localStorage.setItem("lit-keypair",i);const{pubkey:p,errorCode:c}=await async function(e){const t=o.functions().httpsCallable("getPublicKey"),n=await t(e);return console.log(n),n.data}({address:s});if("not_found"===c||p!==e.publicKey){const t=`I am saving my public key so that others can send me LITs.  It is ${p}`,n=await R({body:t});await async function(e){const t=o.functions().httpsCallable("savePublicKey"),n=await t(e);return console.log(n),n.data}({sig:n.signature,msg:t,pubkey:e.publicKey})}}const I={};async function A(a,r){const o=await k();console.log("Got keypair out of localstorage: "+o);const s=o.secretKey;let i=await async function(e){const{account:t}=await v();try{return ethereum.request({method:"eth_decrypt",params:[e,t]})}catch(e){return console.log(e),!1}}(r);i||(console.log("probably not metamask"),i=function(e,a){switch(e.version){case"x25519-xsalsa20-poly1305":{const r=n.decodeBase64(a),o=n.decodeBase64(e.nonce),s=n.decodeBase64(e.ciphertext),i=n.decodeBase64(e.ephemPublicKey),p=t.box.open(s,o,i,r);let c;try{c=n.encodeUTF8(p)}catch(e){throw new Error("Decryption failed.")}if(c)return c;throw new Error("Decryption failed.")}default:throw new Error("Encryption type/version not supported.")}}(r,s)),console.log("decrypted",i);const p=await async function(e){return await crypto.subtle.importKey("jwk",JSON.parse(e),S,!0,["encrypt","decrypt"])}(i),c=await async function(e,t){const n=await e.slice(0,16).arrayBuffer(),a=await e.slice(16).arrayBuffer();return await crypto.subtle.decrypt({name:"AES-CBC",iv:n},t,a)}(a,p),y=new e;return(await y.loadAsync(c)).files}async function F(e){const a=await e.generateAsync({type:"blob"}),r=await a.arrayBuffer();console.log("blob",a);const o=await async function(){return await crypto.subtle.generateKey(S,!0,["encrypt","decrypt"])}(),s=await async function(e,t){const n=window.crypto.getRandomValues(new Uint8Array(16)),a=await crypto.subtle.encrypt({name:"AES-CBC",iv:n},e,t);return new Blob([n,new Uint8Array(a)],{type:"application/octet-stream"})}(o,r),i=await crypto.subtle.exportKey("jwk",o);console.log("exportedSymmKey",i);const p=function(e,a,r){{const r=t.box.keyPair();let o;try{o=n.decodeBase64(e)}catch(e){throw new Error("Bad public key")}const s=n.decodeUTF8(a),i=t.randomBytes(t.box.nonceLength),p=t.box(s,i,o,r.secretKey);return{version:"x25519-xsalsa20-poly1305",nonce:n.encodeBase64(i),ephemPublicKey:n.encodeBase64(r.publicKey),ciphertext:n.encodeBase64(p)}}}((await k()).publicKey,JSON.stringify(i));return{encryptedSymmetricKey:JSON.stringify(p),encryptedZip:s}}async function B(e){if(I[e])return I[e];const t=await fetch("https://unpkg.com/"+e);if(!t.ok)throw console.log("error with response: ",t),Error(t.statusText);const n=await t.blob(),a=await(r=n,new Promise((e,t)=>{const n=new FileReader;n.onloadend=()=>{e(n.result)},n.readAsDataURL(r)}));var r;return I[e]=a,a}const{Request:M,Response:C,StoreKeyFragmentResponse:N,GetKeyFragmentResponse:_}=w("\nmessage Request {\n  enum Type {\n    GET_KEY_FRAGMENT = 0;\n    STORE_KEY_FRAGMENT = 1;\n  }\n  required Type type = 1;\n  optional GetKeyFragment getKeyFragment = 2;\n  optional StoreKeyFragment storeKeyFragment = 3;\n}\nmessage Response {\n  enum Type {\n    GET_KEY_FRAGMENT_RESPONSE = 0;\n    STORE_KEY_FRAGMENT_RESPONSE = 1;\n  }\n  required Type type = 1;\n  optional GetKeyFragmentResponse getKeyFragmentResponse = 2;\n  optional StoreKeyFragmentResponse storeKeyFragmentResponse = 3;\n}\nmessage GetKeyFragment {\n  required bytes keyId = 1;\n}\nmessage GetKeyFragmentResponse {\n  enum Result {\n    SUCCESS = 0;\n    NOT_FOUND = 1;\n    ERROR = 2;\n  }\n  required Result result = 1;\n  optional bytes keyId = 2;\n  optional bytes fragmentValue = 3;\n}\nmessage StoreKeyFragment {\n  required bytes keyId = 1;\n  required bytes fragmentValue = 2;\n}\nmessage StoreKeyFragmentResponse {\n  enum Result {\n    SUCCESS = 0;\n    ERROR = 1;\n  }\n  required Result result = 1;\n  optional bytes errorMessage = 2;\n}\n"),O={zipAndEncryptString:async function(t){const n=new e;return n.file("string.txt",t),F(n)},zipAndEncryptFiles:async function(t){const n=new e;for(let e=0;e<t.length;e++)n.folder("encryptedAssets").file(t[e].name,t[e]);return F(n)},encryptZip:F,decryptZip:A,checkAndDeriveKeypair:k,connectWeb3:v,createHtmlLIT:async function({title:e,htmlBody:t,css:n,encryptedSymmetricKey:a,encryptedZipDataUrl:r,npmPackages:o=[]}){o.push("lit-js-sdk");let s="";for(let e=0;e<o.length;e++)s+=`<script src="${await B(o[e])}"><\/script>\n`;return`\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>${e}</title>\n    <style id="jss-server-side">${n}</style>\n    ${s}\n    <script>\n      var encryptedSymmetricKey = ${a}\n      var encryptedZipDataUrl = "${r}"\n      var locked = true\n    <\/script>\n  </head>\n  <body>\n    <div id="root">${t}</div>\n    <script>\n      const unlockButton = document.getElementById('unlockButton')\n      unlockButton.onclick = function() {\n        LitJsSdk.default.toggleLock()\n      }\n    <\/script>\n  </body>\n</html>\n  `},mintLIT:async function({chain:e,quantity:t}){console.log(`minting ${t} tokens on ${e}`),await k();const{web3:n,account:a}=await v();if(await n.eth.getChainId()!==E[e].chainId)return{errorCode:"wrong_chain"};const r=E[e].contractAddress,o=new n.eth.Contract(K,r);console.log("sending to chain...");try{const e=await o.methods.mint(t).send({from:a});return console.log("txReceipt: ",e),{txHash:e.transactionHash,tokenId:e.events.TransferSingle.returnValues.id,tokenAddress:r,mintingAddress:a}}catch(e){return console.log(e),4001===e.code?(console.log("User rejected request"),{errorCode:"user_rejected_request"}):(console.error(e),{errorCode:"unknown_error"})}},toggleLock:async function(){const e=document.getElementById("mediaGridHolder"),t=document.getElementById("lockedHeader");if(window.locked){window.publicContent=e.innerHTML;const n=await(await fetch(window.encryptedZipDataUrl)).blob(),a=await A(n,JSON.stringify(window.encryptedSymmetricKey)),r=await a["string.txt"].async("text");e.innerHTML=r,t.innerText="UNLOCKED",window.locked=!1}else e.innerHTML=window.publicContent,t.innerText="LOCKED",window.locked=!0},LIT_CHAINS:E,LitNodeClient:class{constructor(e){this.libp2p=null,this.connectedNodes=new Set}async saveEncryptionKey({contractAddress:e,tokenId:t,symmetricKey:n}){const a=Object.keys(this.connectedNodes),r=a.length,o=Math.floor(r/2),s=Buffer.from(n,"base64").toString("hex"),i=f.share(s,r,o);if(i.length!==a.length)throw new Error(`kFrags.length (${i.length}) !== nodeKeys.length (${a.length})`);const p=[],c=e.toLowerCase(),y=t.toString(16).padStart(64,"0");for(let e=0;e<a.length;e++){const t=`${c}|${y}|${e}`;console.debug(`storing kFrag with key ${t} in node ${e+1} of ${a.length}`),p.push(this.storeDataWithNode({peerId:a[e],key:t,val:i[e]}))}return await Promise.all(p),console.log("all stored"),{success:!0}}async storeDataWithNode({peerId:e,key:t,val:n}){const a=g(Buffer.from(t),"sha2-256"),r=new b(a),o=M.encode({type:M.Type.STORE_KEY_FRAGMENT,storeKeyFragment:{keyId:h(r.toString()),fragmentValue:h(n)}});return await this.sendCommandToPeer({peerId:e,data:o})}async getDataFromNode({peerId:e,key:t}){const n=g(Buffer.from(t),"sha2-256"),a=new b(n),r=M.encode({type:M.Type.GET_KEY_FRAGMENT,getKeyFragment:{keyId:h(a.toString())}});return await this.sendCommandToPeer({peerId:e,data:r})}async sendCommandToPeer({peerId:e,data:t}){const n=this.libp2p.connectionManager.get(d.createFromB58String(e)),{stream:a}=await n.newStream(["/lit/1.0.0"]);let r=null;return await m([t],a,async function(e){const{value:t}=await e.next(),n=C.decode(t.slice());n.type===C.Type.STORE_KEY_FRAGMENT_RESPONSE?n.storeKeyFragmentResponse.result===N.Result.SUCCESS?(console.log("success storing key fragment"),r=!0):(console.log("error storing key fragment: "),console.log(T(n.storeKeyFragmentResponse.errorMessage)),r=!1):n.type===C.Type.GET_KEY_FRAGMENT_RESPONSE?n.getKeyFragmentResponse.result===_.Result.SUCCESS?(console.log("success getting key fragment"),r=T(n.getKeyFragmentResponse.fragmentValue)):n.getKeyFragmentResponse.result===_.Result.NOT_FOUND?(console.log("key fragment not found"),r=!1):(console.log("unknown error getting key fragment"),r=!1):console.log("unknown response type")}),r}async connect(){var e=this;this.libp2p=await s.create({modules:{transport:[i,p],connEncryption:[c],streamMuxer:[y],dht:l,peerDiscovery:[u]},config:{dht:{enabled:!0},peerDiscovery:{[u.tag]:{enabled:!0,list:["/ip4/127.0.0.1/tcp/9090/http/p2p-webrtc-direct/p2p/12D3KooWK1KtaAV5rWjbAmZcd62VYSmEz1k81jzr87JAcSS7rKdQ"]}}}}),this.libp2p.on("peer:discovery",e=>{console.debug(`Found peer ${e.toB58String()}`)}),this.libp2p.connectionManager.on("peer:connect",async function(t){const n=t.remotePeer.toB58String();console.debug(`Connected to ${n}`),e.connectedNodes.has(n)||e.connectedNodes.add(n)}),this.libp2p.connectionManager.on("peer:disconnect",e=>{const t=e.remotePeer.toB58String();console.debug(`Disconnected from ${t}`),this.connectedNodes.delete(t)}),await this.libp2p.start(),console.debug(`libp2p id is ${this.libp2p.peerId.toB58String()}`),this.libp2p.multiaddrs.forEach(e=>console.debug(`${e.toString()}/p2p/${this.libp2p.peerId.toB58String()}`)),window.libp2p=this.libp2p,window.PeerId=d}},getUploadUrl:async function(){const e=o.functions().httpsCallable("getUploadUrl"),t=await e();return console.log(t),t.data},createTokenMetadata:async function(e){const t=o.functions().httpsCallable("createTokenMetadata"),n=await t(e);return console.log(n),n.data}};export default O;
//# sourceMappingURL=index.modern.js.map
