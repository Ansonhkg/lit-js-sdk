{"version":3,"file":"index.js","sources":["../node_modules/regenerator-runtime/runtime.js","../src/utils/crypto.js","../src/lib/constants.js","../src/utils/eth.js","../src/utils/lit.js","../src/lib/utils.js","../src/utils/lit-node-client.js","../src/index.js","../src/utils/browser.js"],"sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","\nimport nacl from 'tweetnacl'\nimport naclUtil from 'tweetnacl-util'\n\nconst SYMM_KEY_ALGO_PARAMS = {\n  name: 'AES-CBC',\n  length: 256\n}\n\nexport function compareArrayBuffers (buf1, buf2) {\n  if (buf1.byteLength !== buf2.byteLength) return false\n  const dv1 = new Uint8Array(buf1)\n  const dv2 = new Uint8Array(buf2)\n  for (let i = 0; i !== buf1.byteLength; i++) {\n    if (dv1[i] !== dv2[i]) return false\n  }\n  return true\n}\n\nexport async function importSymmetricKey (jwkSymmKey) {\n  const importedSymmKey = await crypto.subtle.importKey(\n    'jwk',\n    JSON.parse(jwkSymmKey),\n    SYMM_KEY_ALGO_PARAMS,\n    true,\n    ['encrypt', 'decrypt']\n  )\n  return importedSymmKey\n}\nexport async function generateSymmetricKey () {\n  const symmKey = await crypto.subtle.generateKey(\n    SYMM_KEY_ALGO_PARAMS,\n    true,\n    ['encrypt', 'decrypt']\n  )\n  return symmKey\n}\n\nexport async function decryptWithSymmetricKey (\n  encryptedBlob,\n  symmKey\n) {\n  const recoveredIv = await encryptedBlob.slice(0, 16).arrayBuffer()\n  const encryptedZipArrayBuffer = await encryptedBlob.slice(16).arrayBuffer()\n  const decryptedZip = await crypto.subtle.decrypt(\n    {\n      name: 'AES-CBC',\n      iv: recoveredIv\n    },\n    symmKey,\n    encryptedZipArrayBuffer\n  )\n  return decryptedZip\n}\n\n// used this as an example\n// https://github.com/infotechinc/symmetric-encryption-in-browser/blob/master/crypto.js\nexport async function encryptWithSymmetricKey (\n  symmKey,\n  data\n) {\n  // encrypt the zip with symmetric key\n  const iv = window.crypto.getRandomValues(new Uint8Array(16))\n\n  const encryptedZipData = await crypto.subtle.encrypt(\n    {\n      name: 'AES-CBC',\n      iv\n    },\n    symmKey,\n    data\n  )\n  const encryptedZipBlob = new Blob([iv, new Uint8Array(encryptedZipData)], { type: 'application/octet-stream' })\n  return encryptedZipBlob\n}\n\n// borrowed from eth-sig-util from meatmask.\nexport function encryptWithPubKey (\n  receiverPublicKey,\n  data,\n  version\n) {\n  switch (version) {\n    case 'x25519-xsalsa20-poly1305': {\n      // generate ephemeral keypair\n      const ephemeralKeyPair = nacl.box.keyPair()\n\n      // assemble encryption parameters - from string to UInt8\n      let pubKeyUInt8Array\n      try {\n        pubKeyUInt8Array = naclUtil.decodeBase64(receiverPublicKey)\n      } catch (err) {\n        throw new Error('Bad public key')\n      }\n\n      // padding?  not needed for c decryption?\n      // const paddingBytes = new Uint8Array(32)\n      // paddingBytes.fill(0)\n      // const msgParamsUInt8Array = new Uint8Array([...paddingBytes, ...naclUtil.decodeUTF8(data)])\n      const msgParamsUInt8Array = naclUtil.decodeUTF8(data)\n      const nonce = nacl.randomBytes(nacl.box.nonceLength)\n\n      // encrypt\n      const encryptedMessage = nacl.box(\n        msgParamsUInt8Array,\n        nonce,\n        pubKeyUInt8Array,\n        ephemeralKeyPair.secretKey\n      )\n\n      // handle encrypted data\n      const output = {\n        version: 'x25519-xsalsa20-poly1305',\n        nonce: naclUtil.encodeBase64(nonce),\n        ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),\n        ciphertext: naclUtil.encodeBase64(encryptedMessage)\n      }\n      // return encrypted msg data\n      return output\n    }\n\n    default:\n      throw new Error('Encryption type/version not supported')\n  }\n}\n\n// borrowed from eth-sig-util from meatmask.\nexport function decryptWithPrivKey (\n  encryptedData,\n  receiverPrivateKey\n) {\n  switch (encryptedData.version) {\n    case 'x25519-xsalsa20-poly1305': {\n      const recieverEncryptionPrivateKey = naclUtil.decodeBase64(receiverPrivateKey)\n\n      // assemble decryption parameters\n      const nonce = naclUtil.decodeBase64(encryptedData.nonce)\n      const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext)\n      const ephemPublicKey = naclUtil.decodeBase64(\n        encryptedData.ephemPublicKey\n      )\n\n      // decrypt\n      const decryptedMessage = nacl.box.open(\n        ciphertext,\n        nonce,\n        ephemPublicKey,\n        recieverEncryptionPrivateKey\n      )\n\n      console.log('decrypted message: ', decryptedMessage)\n\n      // return decrypted msg data\n      let output\n      try {\n        output = naclUtil.encodeUTF8(decryptedMessage)\n      } catch (err) {\n        throw new Error('Decryption failed.  Could not encode result as utf8')\n      }\n\n      if (output) {\n        return output\n      }\n      throw new Error('Decryption failed.  Output is falsy')\n    }\n\n    default:\n      throw new Error('Encryption type/version not supported.')\n  }\n}\n","import protons from 'protons'\n\nexport const protobufs = protons(`\nmessage Request {\n  enum Type {\n    HANDSHAKE = 0;\n    GET_KEY_FRAGMENT = 1;\n    STORE_KEY_FRAGMENT = 2;\n  }\n  required Type type = 1;\n  optional GetKeyFragment getKeyFragment = 2;\n  optional StoreKeyFragment storeKeyFragment = 3;\n  optional bytes authSig = 4;\n  optional TokenParams tokenParams = 5;\n  optional bytes clientPubKey = 6;\n}\nmessage Response {\n  enum Type {\n    HANDSHAKE_RESPONSE = 0;\n    GET_KEY_FRAGMENT_RESPONSE = 1;\n    STORE_KEY_FRAGMENT_RESPONSE = 2;\n  }\n  required Type type = 1;\n  optional GetKeyFragmentResponse getKeyFragmentResponse = 2;\n  optional StoreKeyFragmentResponse storeKeyFragmentResponse = 3;\n  optional bytes serverPubKey = 4;\n}\nmessage GetKeyFragment {\n  required bytes keyId = 1;\n}\nmessage GetKeyFragmentResponse {\n  enum Result {\n    SUCCESS = 0;\n    NOT_FOUND = 1;\n    ERROR = 2;\n  }\n  required Result result = 1;\n  optional bytes keyId = 2;\n  optional bytes fragmentValue = 3;\n}\nmessage StoreKeyFragment {\n  required bytes fragmentValue = 1;\n}\nmessage StoreKeyFragmentResponse {\n  enum Result {\n    SUCCESS = 0;\n    AUTH_FAILURE = 1;\n    ERROR = 2;\n  }\n  required Result result = 1;\n  optional bytes errorMessage = 2;\n}\nmessage TokenParams {\n  required bytes tokenAddress = 1;\n  required bytes tokenId = 2;\n  required bytes chain = 3;\n}\n`)\n\nexport const LIT_CHAINS = {\n  polygon: {\n    contractAddress: '0xb9A323711528D0c5a70df790929f4739f1cDd7fD',\n    chainId: 137\n  },\n  ethereum: {\n    contractAddress: '0x55485885e82E25446DEC314Ccb810Bda06B9e01B',\n    chainId: 1\n  }\n}\n","import Web3 from 'web3'\n\nimport detectEthereumProvider from '@metamask/detect-provider'\n\nimport naclUtil from 'tweetnacl-util'\nimport nacl from 'tweetnacl'\n\nimport LIT from '../abis/LIT.json'\nimport { LIT_CHAINS } from '../lib/constants'\n\nconst AUTH_SIGNATURE_BODY = 'I am creating an account to use LITs at {{timestamp}}'\n\n// export async function checkAndDeriveKeypair () {\n//   let keypair = localStorage.getItem('lit-keypair')\n//   if (!keypair) {\n//     await deriveEncryptionKeys()\n//     keypair = localStorage.getItem('lit-keypair')\n//   }\n//   keypair = JSON.parse(keypair)\n//   const { web3, account } = await connectWeb3()\n//   // make sure we are on the right account\n//   if (account !== keypair.address) {\n//     await deriveEncryptionKeys()\n//     keypair = localStorage.getItem('lit-keypair')\n//     keypair = JSON.parse(keypair)\n//   }\n//   return keypair\n// }\n\nexport async function connectWeb3 () {\n  if (typeof window.ethereum === 'undefined') {\n    throw new Error({ errorCode: 'no_wallet', message: 'No web3 wallet was found' })\n  }\n\n  const provider = await detectEthereumProvider()\n\n  // trigger metamask popup\n  const accounts = await provider.request({ method: 'eth_requestAccounts' })\n  const account = accounts[0].toLowerCase()\n\n  const web3 = new Web3(provider)\n  return { web3, account }\n}\n\nexport async function checkAndSignAuthMessage () {\n  let authSig = localStorage.getItem('lit-auth-signature')\n  if (!authSig) {\n    await signAndSaveAuthMessage()\n    authSig = localStorage.getItem('lit-auth-signature')\n  }\n  authSig = JSON.parse(authSig)\n  const { web3, account } = await connectWeb3()\n  // make sure we are on the right account\n  if (account !== authSig.address) {\n    await signAndSaveAuthMessage()\n    authSig = localStorage.getItem('lit-auth-signature')\n    authSig = JSON.parse(authSig)\n  }\n  return authSig\n}\n\nexport async function signAndSaveAuthMessage () {\n  const now = (new Date()).toISOString()\n  const body = AUTH_SIGNATURE_BODY.replace('{{timestamp}}', now)\n  const signedResult = await signMessage({ body })\n  localStorage.setItem('lit-auth-signature', JSON.stringify({\n    sig: signedResult.signature,\n    derivedVia: 'web3.eth.personal.sign',\n    signedMessage: body,\n    address: signedResult.address\n  }))\n  // store a keypair in localstorage for communication with sgx\n  const commsKeyPair = nacl.box.keyPair()\n  localStorage.setItem('lit-comms-keypair', JSON.stringify({\n    publicKey: naclUtil.encodeBase64(commsKeyPair.publicKey),\n    secretKey: naclUtil.encodeBase64(commsKeyPair.secretKey)\n  }))\n}\n\nexport async function signMessage ({ body }) {\n  const { web3, account } = await connectWeb3()\n\n  console.log('signing with ', account)\n  const signature = await web3.eth.personal.sign(body, account)\n  const address = web3.eth.accounts.recover(body, signature).toLowerCase()\n\n  console.log('Signature: ', signature)\n  console.log('recovered address: ', address)\n\n  if (address !== account) {\n    const msg = `ruh roh, the user signed with a different address (${address}) then they\\'re using with web3 (${account}).  this will lead to confusion.`\n    console.error(msg)\n    alert('something seems to be wrong with your wallets message signing.  maybe restart your browser or your wallet.  your recovered sig address does not match your web3 account address')\n    throw new Error(msg)\n  }\n\n  return { signature, address }\n}\n\n// export async function decryptWithWeb3PrivateKey (encryptedData) {\n//   const { web3, account } = await connectWeb3()\n//   try {\n//     const decryptedMessage = ethereum\n//       .request({\n//         method: 'eth_decrypt',\n//         params: [encryptedData, account]\n//       })\n//     return decryptedMessage\n//   } catch (error) {\n//     console.log(error)\n//     return false\n//   }\n// }\n//\n// async function deriveKeysViaSignature () {\n//   const { signature, address } = await signMessage({ body: KEY_DERIVATION_SIGNATURE_BODY })\n//   console.log('Signed message: ' + signature)\n//\n//   // derive keypair\n//   const data = Buffer.from(signature.substring(2), 'hex')\n//   const hash = await crypto.subtle.digest('SHA-256', data)\n//   const uint8Hash = new Uint8Array(hash)\n//   const { publicKey, secretKey } = nacl.box.keyPair.fromSecretKey(uint8Hash)\n//   return {\n//     publicKey: naclUtil.encodeBase64(publicKey),\n//     secretKey: naclUtil.encodeBase64(secretKey)\n//   }\n// }\n//\n// // this only works on metamask :(\n// async function deriveKeysViaPrivateKey () {\n//   try {\n//     const { web3, account } = await connectWeb3()\n//     /* global ethereum */\n//     /* eslint no-undef: \"error\" */\n//     const publicKey = await ethereum\n//       .request({\n//         method: 'eth_getEncryptionPublicKey',\n//         params: [account] // you must have access to the specified account\n//       })\n//     return { publicKey }\n//   } catch (error) {\n//     console.log(error)\n//     if (error.code === 4001) {\n//       // EIP-1193 userRejectedRequest error\n//       console.log(\"We can't encrypt anything without the key.\")\n//       error('You must accept the metamask request to derive your public encryption key')\n//     } else {\n//       console.error(error)\n//     }\n//     return { error }\n//   }\n// }\n//\n// export async function deriveEncryptionKeys () {\n//   let keypair = {}\n//   // key derivation via metamask is more desirable because then even this SDK can't see the secret key :-D\n//   const { error, publicKey } = await deriveKeysViaPrivateKey()\n//   if (!error) {\n//     keypair = {\n//       publicKey,\n//       derivedVia: 'eth_getEncryptionPublicKey'\n//     }\n//   } else {\n//     const { publicKey, secretKey } = await deriveKeysViaSignature()\n//     keypair = {\n//       publicKey,\n//       secretKey,\n//       derivedVia: 'web3.eth.personal.sign',\n//       signedMessage: KEY_DERIVATION_SIGNATURE_BODY\n//     }\n//   }\n//\n//   const { web3, account } = await connectWeb3()\n//   keypair.address = account\n//\n//   console.log('public key: ' + keypair.publicKey)\n//   const asString = JSON.stringify(keypair)\n//   localStorage.setItem('lit-keypair', asString)\n//\n//   // is it already saved on the server?\n//   const { pubkey, errorCode } = await getPublicKey({\n//     address: account\n//   })\n//   if (errorCode === 'not_found' || pubkey !== keypair.publicKey) {\n//     // add it\n//     const msg = `I am saving my public key so that others can send me LITs.  It is ${pubkey}`\n//     const res = await signMessage({ body: msg })\n//     await savePublicKey({\n//       sig: res.signature,\n//       msg,\n//       pubkey: keypair.publicKey\n//     })\n//   }\n// }\n\nexport async function mintLIT ({ chain, quantity }) {\n  console.log(`minting ${quantity} tokens on ${chain}`)\n  const authSig = await checkAndSignAuthMessage()\n  const { web3, account } = await connectWeb3()\n  const chainId = await web3.eth.getChainId()\n  if (chainId !== LIT_CHAINS[chain].chainId) {\n    return { errorCode: 'wrong_chain' }\n  }\n  const tokenAddress = LIT_CHAINS[chain].contractAddress\n  const contract = new web3.eth.Contract(LIT.abi, tokenAddress)\n  console.log('sending to chain...')\n  try {\n    const txReceipt = await contract.methods.mint(quantity).send({ from: account })\n    console.log('txReceipt: ', txReceipt)\n    const tokenId = txReceipt.events.TransferSingle.returnValues.id\n    return {\n      txHash: txReceipt.transactionHash,\n      tokenId,\n      tokenAddress,\n      mintingAddress: account,\n      authSig\n    }\n  } catch (error) {\n    console.log(error)\n    if (error.code === 4001) {\n      // EIP-1193 userRejectedRequest error\n      console.log('User rejected request')\n      return { errorCode: 'user_rejected_request' }\n    } else {\n      console.error(error)\n    }\n    return { errorCode: 'unknown_error' }\n  }\n}\n","import JSZip from 'jszip'\n\nimport {\n  importSymmetricKey,\n  generateSymmetricKey,\n  encryptWithSymmetricKey,\n  decryptWithSymmetricKey,\n  compareArrayBuffers\n} from './crypto'\n\nimport {\n  checkAndSignAuthMessage\n} from './eth'\n\nimport { fileToDataUrl } from './browser'\n\nconst PACKAGE_CACHE = {}\n\nexport async function zipAndEncryptString (string) {\n  const zip = new JSZip()\n  zip.file('string.txt', string)\n  return encryptZip(zip)\n}\n\nexport async function zipAndEncryptFiles (files) {\n  // let's zip em\n  const zip = new JSZip()\n  for (let i = 0; i < files.length; i++) {\n    zip.folder('encryptedAssets').file(files[i].name, files[i])\n  }\n  return encryptZip(zip)\n}\n\nexport async function decryptZip (encryptedZipBlob, symmKey) {\n  // const keypair = await checkAndDeriveKeypair()\n\n  // console.log('Got keypair out of localstorage: ' + keypair)\n  // const privkey = keypair.secretKey\n\n  // let decryptedSymmKey = await decryptWithWeb3PrivateKey(symmKey)\n  // if (!decryptedSymmKey) {\n  //   // fallback to trying the private derived via signature\n  //   console.log('probably not metamask')\n  //   decryptedSymmKey = decryptWithPrivkey(symmKey, privkey)\n  // }\n  // console.log('decrypted', decryptedSymmKey)\n\n  // import the decrypted symm key\n  const importedSymmKey = await importSymmetricKey(symmKey)\n\n  const decryptedZipArrayBuffer = await decryptWithSymmetricKey(\n    encryptedZipBlob,\n    importedSymmKey\n  )\n\n  // unpack the zip\n  const zip = new JSZip()\n  const unzipped = await zip.loadAsync(decryptedZipArrayBuffer)\n\n  // load the files into data urls with the metadata attached\n  // const files = await Promise.all(unzipped.files.map(async f => {\n  //   // const dataUrl = await fileToDataUrl(f)\n  //   return {\n  //     type: f.type,\n  //     name: f.name,\n  //     file: f\n  //   }\n  // }))\n\n  return unzipped.files\n}\n\nexport async function encryptZip (zip) {\n  const zipBlob = await zip.generateAsync({ type: 'blob' })\n  const zipBlobArrayBuffer = await zipBlob.arrayBuffer()\n  console.log('blob', zipBlob)\n\n  const symmKey = await generateSymmetricKey()\n  const encryptedZipBlob = await encryptWithSymmetricKey(\n    symmKey,\n    zipBlobArrayBuffer\n  )\n\n  // to download the encrypted zip file for testing, uncomment this\n  // saveAs(encryptedZipBlob, 'encrypted.bin')\n\n  const exportedSymmKey = await crypto.subtle.exportKey('jwk', symmKey)\n  console.log('exportedSymmKey', exportedSymmKey)\n\n  // encrypt the symmetric key with the\n  // public key derived from the eth wallet\n  // const keypair = await checkAndDeriveKeypair()\n  // const pubkey = keypair.publicKey\n  // const privkey = keypair.secretKey\n\n  // encrypt symm key\n  // const encryptedSymmKeyData = encryptWithPubkey(pubkey, JSON.stringify(exportedSymmKey), 'x25519-xsalsa20-poly1305')\n  // const packed = JSON.stringify(encryptedSymmKeyData)\n\n  //   console.log('packed symmetric key ', packed)\n  //   const unpacked = JSON.parse(packed)\n  //   // test decrypt\n  //   const decryptedSymmKey = decryptWithPrivkey(unpacked, privkey)\n  //   console.log('decrypted', decryptedSymmKey)\n  //\n  //   // import the decrypted symm key\n  //   const importedSymmKey = await importSymmetricKey(decryptedSymmKey)\n  //\n  //   const decryptedZipArrayBuffer = await decryptWithSymmetricKey(\n  //     encryptedZipBlob,\n  //     importedSymmKey\n  //   )\n  //\n  //   // compare zip before and after as a sanity check\n  //   const isEqual = compareArrayBuffers(\n  //     zipBlobArrayBuffer,\n  //     decryptedZipArrayBuffer\n  //   )\n  //   console.log('Zip before and after decryption are equal: ', isEqual)\n  //   if (!isEqual) {\n  //     throw new Error('Decrypted zip does not match original zip.  Something is wrong.')\n  //   }\n\n  // to download the zip, for testing, uncomment this\n  //   const decryptedBlob = new Blob(\n  //     [decryptedZipArrayBuffer],\n  //     { type: 'application/zip' }\n  //   )\n  //   console.log('decrypted blob', decryptedBlob)\n  //\n  //   saveAs(decryptedBlob, 'decrypted.zip')\n  // console.log('saved')\n\n  return {\n    symmetricKey: JSON.stringify(exportedSymmKey),\n    encryptedZip: encryptedZipBlob\n  }\n}\n\nasync function getNpmPackage (packageName) {\n  // console.log('getting npm package: ' + packageName)\n  if (PACKAGE_CACHE[packageName]) {\n    // console.log('found in cache')\n    return PACKAGE_CACHE[packageName]\n  }\n\n  const resp = await fetch('https://unpkg.com/' + packageName)\n  if (!resp.ok) {\n    console.log('error with response: ', resp)\n    throw Error(resp.statusText)\n  }\n  const blob = await resp.blob()\n  // console.log('got blob', blob)\n  const dataUrl = await fileToDataUrl(blob)\n  // console.log('got dataUrl', dataUrl)\n  PACKAGE_CACHE[packageName] = dataUrl\n  return dataUrl\n}\n\nexport async function createHtmlLIT ({\n  title,\n  htmlBody,\n  css,\n  encryptedZipDataUrl,\n  tokenAddress,\n  tokenId,\n  chain,\n  npmPackages = []\n}) {\n  // npmPackages.push('lit-js-sdk')\n  // console.log('createHtmlLIT with npmPackages', npmPackages)\n  let scriptTags = ''\n  for (let i = 0; i < npmPackages.length; i++) {\n    const scriptDataUrl = await getNpmPackage(npmPackages[i])\n    const tag = `<script src=\"${scriptDataUrl}\"></script>\\n`\n    scriptTags += tag\n  }\n\n  // console.log('scriptTags: ', scriptTags)\n\n  return `\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>${title}</title>\n    <style id=\"jss-server-side\">${css}</style>\n    ${scriptTags}\n    <script>\n      var encryptedZipDataUrl = \"${encryptedZipDataUrl}\"\n      var tokenAddress = \"${tokenAddress}\"\n      var tokenId = \"${tokenId}\"\n      var chain = \"${chain}\"\n      var locked = true\n\n      function litJsSdkLoaded(){\n         var litNodeClient = new LitJsSdk.default.LitNodeClient()\n        litNodeClient.connect()\n        window.litNodeClient = litNodeClient\n      }\n    </script>\n    <script onload='litJsSdkLoaded()' src=\"https://unpkg.com/lit-js-sdk/build/index.web.js\"></script>\n  </head>\n  <body>\n    <div id=\"root\">${htmlBody}</div>\n    <script>\n      const unlockButton = document.getElementById('unlockButton')\n      unlockButton.onclick = function() {\n        LitJsSdk.default.toggleLock()\n      }\n    </script>\n  </body>\n</html>\n  `\n}\n\nexport async function toggleLock () {\n  const mediaGridHolder = document.getElementById('mediaGridHolder')\n  const lockedHeader = document.getElementById('lockedHeader')\n\n  if (window.locked) {\n    // save public content before decryption, so we can toggle back to the\n    // locked state in the future\n    window.publicContent = mediaGridHolder.innerHTML\n\n    const authSig = await checkAndSignAuthMessage()\n    // get the encryption key\n    const symmetricKey = await window.litNodeClient.getEncryptionKey({\n      tokenAddress: window.tokenAddress,\n      tokenId: window.tokenId,\n      authSig,\n      chain: window.chain\n    })\n\n    // convert data url to blob\n    const encryptedZipBlob = await (await fetch(window.encryptedZipDataUrl)).blob()\n    const decryptedFiles = await decryptZip(encryptedZipBlob, symmetricKey)\n    const mediaGridHtmlBody = await decryptedFiles['string.txt'].async('text')\n    mediaGridHolder.innerHTML = mediaGridHtmlBody\n    lockedHeader.innerText = 'UNLOCKED'\n    window.locked = false\n  } else {\n    mediaGridHolder.innerHTML = window.publicContent\n    lockedHeader.innerText = 'LOCKED'\n    window.locked = true\n  }\n}\n","import multihashing from 'multihashing'\nimport CID from 'cids'\n\nexport const kFragKey = ({ tokenAddress, tokenId, chain }) => {\n  const normalizedTokenAddress = tokenAddress.toLowerCase()\n  const normalizedTokenId = tokenId.toString(16).padStart(64, '0') // to hex and padded for consistent length\n  const formattedKey = `${normalizedTokenAddress}|${normalizedTokenId}|${chain}`\n  const hashed = multihashing(Buffer.from(formattedKey), 'sha2-256')\n  const cid = new CID(hashed)\n  return cid.toString()\n}\n","// import 'babel-polyfill'\nimport Libp2p from 'libp2p'\nimport Websockets from 'libp2p-websockets'\nimport WebRTCDirect from 'libp2p-webrtc-direct'\nimport { NOISE } from 'libp2p-noise'\nimport Mplex from 'libp2p-mplex'\nimport KadDHT from 'libp2p-kad-dht'\nimport PeerId from 'peer-id'\nimport { multiaddr } from 'multiaddr'\nimport Bootstrap from 'libp2p-bootstrap'\nimport pipe from 'it-pipe'\nimport lp from 'it-length-prefixed'\nimport multihashing from 'multihashing'\nimport CID from 'cids'\nimport pushable from 'it-pushable'\nimport secrets from 'secrets.js-lit'\nimport uint8arrayFromString from 'uint8arrays/from-string'\nimport uint8arrayToString from 'uint8arrays/to-string'\nimport all from 'it-all'\nimport naclUtil from 'tweetnacl-util'\n\nimport { protobufs } from '../lib/constants'\nimport { kFragKey } from '../lib/utils'\nimport { encryptWithPubKey, decryptWithPrivKey } from './crypto'\n\nconst { Request, Response, StoreKeyFragmentResponse, GetKeyFragmentResponse } = protobufs\n\nexport default class LitNodeClient {\n  constructor (config) {\n    this.libp2p = null\n    this.connectedNodes = new Set()\n    this.serverPubKeys = {}\n  }\n\n  async getEncryptionKey ({ tokenAddress, tokenId, authSig, chain }) {\n    const encryptedKFrags = await this.getEncryptionKeyFragments({ tokenAddress, tokenId, authSig, chain })\n    const commsKeypair = JSON.parse(localStorage.getItem('lit-comms-keypair'))\n    // decrypt kfrags\n    const kFrags = []\n    for (let i = 0; i < encryptedKFrags.length; i++) {\n      console.log('decrypting kfrag ' + encryptedKFrags[i])\n      const decrypted = decryptWithPrivKey(JSON.parse(encryptedKFrags[i]), commsKeypair.secretKey)\n      kFrags.push(decrypted)\n    }\n    const secret = secrets.combine(kFrags)\n    const symmetricKey = Buffer.from(secret, 'hex').toString()\n    console.log('recombined symmetric key: ' + symmetricKey)\n    return symmetricKey\n  }\n\n  async saveEncryptionKey ({ tokenAddress, tokenId, symmetricKey, authSig, chain }) {\n    console.log(`saveEncryptionKey with tokenAddress ${tokenAddress} and tokenId ${tokenId} and symmetricKey ${symmetricKey} and authSig ${authSig} and chain ${chain}`)\n    const nodes = Array.from(this.connectedNodes)\n    // split up into nodes.length fragments\n    const numShares = nodes.length\n    const threshold = Math.floor(numShares / 2)\n    // convert from base64 to hex\n    const secret = Buffer.from(symmetricKey).toString('hex')\n    console.debug(`splitting up into ${numShares} shares with a threshold of ${threshold}`)\n    const kFrags = secrets.share(secret, numShares, threshold)\n    if (kFrags.length !== nodes.length) {\n      throw new Error(`kFrags.length (${kFrags.length}) !== nodes.length (${nodes.length})`)\n    }\n    const storagePromises = []\n    const normalizedTokenAddress = tokenAddress.toLowerCase()\n    for (let i = 0; i < nodes.length; i++) {\n      const peerId = nodes[i]\n      console.debug(`storing kFrag in node ${i + 1} of ${nodes.length}`)\n      // encrypt kfrag with sgx key\n      console.log('kfrag before encrypting: ' + kFrags[i])\n      const serverPubKey = naclUtil.encodeBase64(this.serverPubKeys[peerId])\n      const encryptedKFrag = JSON.stringify(encryptWithPubKey(serverPubKey, kFrags[i], 'x25519-xsalsa20-poly1305'))\n      console.log('encrypted kFrag is ' + encryptedKFrag)\n      storagePromises.push(\n        this.storeDataWithNode({\n          peerId,\n          tokenAddress: normalizedTokenAddress,\n          tokenId,\n          val: encryptedKFrag,\n          authSig,\n          chain\n        })\n      )\n    }\n    await Promise.all(storagePromises)\n    console.log('all stored')\n    return { success: true }\n  }\n\n  async getEncryptionKeyFragments ({ tokenAddress, tokenId, authSig, chain }) {\n    // find providers\n    const normalizedTokenAddress = tokenAddress.toLowerCase()\n    const keyId = kFragKey({ tokenAddress, tokenId, chain })\n    const cid = new CID(keyId)\n    const providers = await all(this.libp2p.contentRouting.findProviders(cid, { timeout: 3000 }))\n    console.log(`Found ${providers.length} providers`)\n    const kFragPromises = []\n    for (let i = 0; i < providers.length; i++) {\n      const peerId = providers[i].id.toB58String()\n      console.debug(`Getting ${keyId} from ${peerId}`)\n      kFragPromises.push(this.getDataFromNode({\n        peerId,\n        tokenAddress: normalizedTokenAddress,\n        tokenId,\n        authSig,\n        keyId,\n        chain\n      }))\n    }\n    const kFrags = await Promise.all(kFragPromises)\n    return kFrags\n  }\n\n  async storeDataWithNode ({ peerId, tokenAddress, tokenId, val, authSig, chain }) {\n    console.debug(`storing data with node ${peerId} with tokenAddress ${tokenAddress} and tokenId ${tokenId}`)\n    const data = Request.encode({\n      type: Request.Type.STORE_KEY_FRAGMENT,\n      storeKeyFragment: {\n        fragmentValue: uint8arrayFromString(val)\n      },\n      authSig: uint8arrayFromString(JSON.stringify(authSig)),\n      tokenParams: {\n        tokenAddress: uint8arrayFromString(tokenAddress),\n        tokenId: uint8arrayFromString(tokenId.toString()),\n        chain: uint8arrayFromString(chain)\n      }\n    })\n    return await this.sendCommandToPeer({ peerId, data })\n  }\n\n  async getDataFromNode ({ peerId, tokenAddress, tokenId, keyId, authSig, chain }) {\n    console.debug(`getDataFromNode ${peerId} with keyId ${keyId}`)\n    const commsKeypair = JSON.parse(localStorage.getItem('lit-comms-keypair'))\n    const data = Request.encode({\n      type: Request.Type.GET_KEY_FRAGMENT,\n      getKeyFragment: {\n        keyId: uint8arrayFromString(keyId)\n      },\n      authSig: uint8arrayFromString(JSON.stringify(authSig)),\n      tokenParams: {\n        tokenAddress: uint8arrayFromString(tokenAddress),\n        tokenId: uint8arrayFromString(tokenId.toString()),\n        chain: uint8arrayFromString(chain)\n      },\n      clientPubKey: naclUtil.decodeBase64(commsKeypair.publicKey)\n    })\n    return await this.sendCommandToPeer({ peerId, data })\n  }\n\n  async handshakeWithSgx ({ peerId }) {\n    console.debug(`handshakeWithSgx ${peerId}`)\n    const data = Request.encode({\n      type: Request.Type.HANDSHAKE\n      // TODO clientPubKey:\n    })\n    return await this.sendCommandToPeer({ peerId, data })\n  }\n\n  async sendCommandToPeer ({ peerId, data }) {\n    const connection = this.libp2p.connectionManager.get(PeerId.createFromB58String(peerId))\n    const { stream } = await connection.newStream(['/lit/1.0.0'])\n    console.debug(`sendCommandToPeer ${peerId}`)\n    let retVal = null\n    await pipe(\n      [data],\n      stream,\n      async (source) => {\n        console.debug('in sendCommandToPeer callback')\n        const { value, done } = await source.next()\n        console.debug('got value from source.next()', value)\n        const resp = Response.decode(value.slice())\n        if (resp.type === Response.Type.HANDSHAKE_RESPONSE) {\n          // save pubkey\n          this.serverPubKeys[peerId] = resp.serverPubKey\n          console.log('handshake success for ' + peerId + ' - got server pub key ' + naclUtil.encodeBase64(resp.serverPubKey))\n          retVal = true\n        } else if (resp.type === Response.Type.STORE_KEY_FRAGMENT_RESPONSE) {\n          if (resp.storeKeyFragmentResponse.result === StoreKeyFragmentResponse.Result.SUCCESS) {\n            console.log('success storing key fragment')\n            retVal = true\n          } else {\n            console.log('error storing key fragment: ')\n            console.log(uint8arrayToString(resp.storeKeyFragmentResponse.errorMessage))\n            retVal = false\n          }\n        } else if (resp.type === Response.Type.GET_KEY_FRAGMENT_RESPONSE) {\n          if (resp.getKeyFragmentResponse.result === GetKeyFragmentResponse.Result.SUCCESS) {\n            console.log('success getting key fragment')\n            retVal = uint8arrayToString(resp.getKeyFragmentResponse.fragmentValue)\n          } else if (resp.getKeyFragmentResponse.result === GetKeyFragmentResponse.Result.NOT_FOUND) {\n            console.log('key fragment not found')\n            retVal = false\n          } else {\n            console.log('unknown error getting key fragment')\n            retVal = false\n          }\n        } else {\n          console.log('unknown response type')\n        }\n      }\n    )\n    return retVal\n  }\n\n  async connect () {\n    const hardcodedPeerId = '12D3KooWK1KtaAV5rWjbAmZcd62VYSmEz1k81jzr87JAcSS7rKdQ'\n    // Create our libp2p node\n    this.libp2p = await Libp2p.create({\n      modules: {\n        transport: [Websockets, WebRTCDirect],\n        connEncryption: [NOISE],\n        streamMuxer: [Mplex],\n        dht: KadDHT,\n        peerDiscovery: [Bootstrap]\n      },\n      config: {\n        dht: {\n          enabled: true\n        },\n        peerDiscovery: {\n          [Bootstrap.tag]: {\n            enabled: true,\n            list: [`/ip4/51.222.108.215/tcp/9090/http/p2p-webrtc-direct/p2p/${hardcodedPeerId}`]\n          }\n        }\n      }\n    })\n\n    // Listen for new peers\n    this.libp2p.on('peer:discovery', (peerId) => {\n      console.debug(`Found peer ${peerId.toB58String()}`)\n    })\n\n    // Listen for new connections to peers\n    this.libp2p.connectionManager.on('peer:connect', async (connection) => {\n      const peerId = connection.remotePeer.toB58String()\n      console.debug(`Connected to ${peerId}`)\n      if (this.connectedNodes.has(peerId)) {\n        return\n      }\n      this.connectedNodes.add(peerId)\n      // handshake.  wait a second for the connection to settle.\n      setTimeout(async () => {\n        await this.handshakeWithSgx({ peerId })\n      }, 1000)\n    })\n\n    // Listen for peers disconnecting\n    this.libp2p.connectionManager.on('peer:disconnect', (connection) => {\n      const peerId = connection.remotePeer.toB58String()\n      console.debug(`Disconnected from ${peerId}`)\n      this.connectedNodes.delete(peerId)\n    })\n\n    await this.libp2p.start()\n    console.debug(`libp2p id is ${this.libp2p.peerId.toB58String()}`)\n    this.libp2p.multiaddrs.forEach((ma) => console.debug(`${ma.toString()}/p2p/${this.libp2p.peerId.toB58String()}`))\n\n    // Export libp2p to the window so you can play with the API\n    window.libp2p = this.libp2p\n    window.PeerId = PeerId\n    // const hashed = multihashing(Buffer.from('1'), 'sha2-256')\n    // window.cid = new CID(hashed)\n\n    // const node1PeerId = PeerId.createFromB58String('QmXQtURimWjx8ihhWp1jjMv3rnv8xzq1qwY6KSzMr8dSGL')\n    // const ma = multiaddr('/ip4/127.0.0.1/tcp/9092/ws/p2p')\n    // libp2p.peerStore.addressBook.set(node1PeerId, [ma])\n  }\n}\n","import 'regenerator-runtime/runtime'\n\nimport {\n  zipAndEncryptString,\n  zipAndEncryptFiles,\n  encryptZip,\n  decryptZip,\n  createHtmlLIT,\n  toggleLock\n} from './utils/lit'\n\nimport {\n  connectWeb3,\n  mintLIT,\n  checkAndSignAuthMessage\n} from './utils/eth'\n\nimport { LIT_CHAINS, protobufs } from './lib/constants'\nimport { kFragKey } from './lib/utils'\n\nimport LitNodeClient from './utils/lit-node-client'\n\nconst functions = {\n  zipAndEncryptString,\n  zipAndEncryptFiles,\n  encryptZip,\n  decryptZip,\n  connectWeb3,\n  checkAndSignAuthMessage,\n  createHtmlLIT,\n  mintLIT,\n  toggleLock,\n  LIT_CHAINS,\n  LitNodeClient,\n  protobufs,\n  kFragKey\n}\n\nexport default functions\n","export function fileToDataUrl (file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader()\n    reader.onloadend = () => {\n      resolve(reader.result)\n    }\n    reader.readAsDataURL(file)\n  })\n}\n"],"names":["runtime","exports","undefined","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","GenStateSuspendedStart","method","arg","GenStateExecuting","Error","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","done","GenStateSuspendedYield","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","invoke","resolve","reject","result","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","SYMM_KEY_ALGO_PARAMS","encryptWithPubKey","receiverPublicKey","data","version","pubKeyUInt8Array","ephemeralKeyPair","nacl","box","keyPair","naclUtil","decodeBase64","msgParamsUInt8Array","decodeUTF8","nonce","randomBytes","nonceLength","encryptedMessage","secretKey","encodeBase64","ephemPublicKey","publicKey","ciphertext","decryptWithPrivKey","encryptedData","receiverPrivateKey","output","recieverEncryptionPrivateKey","decryptedMessage","open","console","log","encodeUTF8","protobufs","protons","LIT_CHAINS","polygon","contractAddress","chainId","ethereum","signAndSaveAuthMessage","now","Date","toISOString","body","AUTH_SIGNATURE_BODY","replace","connectWeb3","web3","account","eth","personal","sign","signature","address","accounts","recover","toLowerCase","msg","alert","signMessage","signedResult","localStorage","setItem","JSON","stringify","sig","derivedVia","signedMessage","commsKeyPair","checkAndSignAuthMessage","authSig","parse","getItem","window","errorCode","message","detectEthereumProvider","provider","request","Web3","pact","s","o","_settle","bind","v","observer","_Pact","onFulfilled","onRejected","callback","e","_this","encryptZip","zip","generateAsync","zipBlob","arrayBuffer","zipBlobArrayBuffer","crypto","subtle","generateKey","generateSymmetricKey","symmKey","iv","getRandomValues","Uint8Array","encrypt","encryptedZipData","Blob","encryptWithSymmetricKey","encryptedZipBlob","exportKey","exportedSymmKey","symmetricKey","encryptedZip","decryptZip","jwkSymmKey","importKey","importSymmetricKey","importedSymmKey","encryptedBlob","recoveredIv","encryptedZipArrayBuffer","decrypt","decryptWithSymmetricKey","decryptedZipArrayBuffer","JSZip","loadAsync","unzipped","files","PACKAGE_CACHE","kFragKey","tokenId","chain","normalizedTokenAddress","tokenAddress","normalizedTokenId","padStart","hashed","multihashing","Buffer","from","CID","Request","Response","StoreKeyFragmentResponse","GetKeyFragmentResponse","zipAndEncryptString","string","file","zipAndEncryptFiles","folder","createHtmlLIT","array","title","htmlBody","css","encryptedZipDataUrl","npmPackages","scriptTags","packageName","fetch","resp","ok","statusText","blob","reader","FileReader","onloadend","readAsDataURL","dataUrl","getNpmPackage","scriptDataUrl","_cycle","thenable","mintLIT","quantity","getChainId","contract","Contract","LIT","methods","mint","send","txReceipt","txHash","transactionHash","events","TransferSingle","returnValues","id","mintingAddress","code","toggleLock","mediaGridHolder","document","getElementById","lockedHeader","locked","publicContent","innerHTML","litNodeClient","getEncryptionKey","_fetch","decryptedFiles","mediaGridHtmlBody","innerText","LitNodeClient","config","libp2p","connectedNodes","Set","serverPubKeys","getEncryptionKeyFragments","encryptedKFrags","commsKeypair","kFrags","decrypted","secret","secrets","combine","saveEncryptionKey","nodes","Array","_this4","numShares","threshold","Math","floor","debug","share","storagePromises","peerId","serverPubKey","encryptedKFrag","storeDataWithNode","val","all","success","keyId","cid","_this6","contentRouting","findProviders","timeout","providers","kFragPromises","toB58String","getDataFromNode","encode","Type","STORE_KEY_FRAGMENT","storeKeyFragment","fragmentValue","uint8arrayFromString","tokenParams","sendCommandToPeer","GET_KEY_FRAGMENT","getKeyFragment","clientPubKey","handshakeWithSgx","HANDSHAKE","connection","_this14","connectionManager","get","PeerId","createFromB58String","newStream","stream","retVal","pipe","source","decode","HANDSHAKE_RESPONSE","STORE_KEY_FRAGMENT_RESPONSE","storeKeyFragmentResponse","Result","SUCCESS","uint8arrayToString","errorMessage","GET_KEY_FRAGMENT_RESPONSE","getKeyFragmentResponse","NOT_FOUND","connect","Libp2p","modules","transport","Websockets","WebRTCDirect","connEncryption","NOISE","streamMuxer","Mplex","dht","KadDHT","peerDiscovery","Bootstrap","enabled","tag","list","_this16","on","remotePeer","has","add","setTimeout","start","multiaddrs","ma"],"mappings":"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"}