{"version":3,"file":"index.esm.js","sources":["../node_modules/regenerator-runtime/runtime.js","../src/utils/crypto.js","../src/lib/constants.js","../src/utils/eth.js","../src/utils/frameComms.js","../src/utils/browser.js","../src/utils/lit.js","../src/lib/utils.js","../src/utils/litNodeClient.js","../src/index.js","../src/utils/init.js"],"sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","\nimport nacl from 'tweetnacl'\nimport naclUtil from 'tweetnacl-util'\n\nconst SYMM_KEY_ALGO_PARAMS = {\n  name: 'AES-CBC',\n  length: 256\n}\n\nexport function compareArrayBuffers (buf1, buf2) {\n  if (buf1.byteLength !== buf2.byteLength) return false\n  const dv1 = new Uint8Array(buf1)\n  const dv2 = new Uint8Array(buf2)\n  for (let i = 0; i !== buf1.byteLength; i++) {\n    if (dv1[i] !== dv2[i]) return false\n  }\n  return true\n}\n\nexport async function importSymmetricKey (jwkSymmKey) {\n  const importedSymmKey = await crypto.subtle.importKey(\n    'jwk',\n    JSON.parse(jwkSymmKey),\n    SYMM_KEY_ALGO_PARAMS,\n    true,\n    ['encrypt', 'decrypt']\n  )\n  return importedSymmKey\n}\nexport async function generateSymmetricKey () {\n  const symmKey = await crypto.subtle.generateKey(\n    SYMM_KEY_ALGO_PARAMS,\n    true,\n    ['encrypt', 'decrypt']\n  )\n  return symmKey\n}\n\n/**\n * Decrypt an encrypted blob with a symmetric key.  Uses AES-CBC via SubtleCrypto\n * @param {Blob} encryptedBlob The encrypted blob that should be decrypted\n * @param {Object} symmKey The symmetric key\n * @returns {Blob} The decrypted blob\n */\nexport async function decryptWithSymmetricKey (\n  encryptedBlob,\n  symmKey\n) {\n  const recoveredIv = await encryptedBlob.slice(0, 16).arrayBuffer()\n  const encryptedZipArrayBuffer = await encryptedBlob.slice(16).arrayBuffer()\n  const decryptedZip = await crypto.subtle.decrypt(\n    {\n      name: 'AES-CBC',\n      iv: recoveredIv\n    },\n    symmKey,\n    encryptedZipArrayBuffer\n  )\n  return decryptedZip\n}\n\n// used this as an example\n// https://github.com/infotechinc/symmetric-encryption-in-browser/blob/master/crypto.js\n/**\n * Encrypt a blob with a symmetric key\n * @param {Object} symmKey The symmetric key\n * @param {Blob} data The blob to encrypt\n * @returns {Blob} The encrypted blob\n */\nexport async function encryptWithSymmetricKey (\n  symmKey,\n  data\n) {\n  // encrypt the zip with symmetric key\n  const iv = window.crypto.getRandomValues(new Uint8Array(16))\n\n  const encryptedZipData = await crypto.subtle.encrypt(\n    {\n      name: 'AES-CBC',\n      iv\n    },\n    symmKey,\n    data\n  )\n  const encryptedZipBlob = new Blob([iv, new Uint8Array(encryptedZipData)], { type: 'application/octet-stream' })\n  return encryptedZipBlob\n}\n\n// borrowed from eth-sig-util from meatmask.\n/**\n * Encrypt a blob with the public key of a receiver\n * @param {string} receiverPublicKey The base64 encoded 32 byte public key.  The corresponding private key will be able to decrypt this blob\n * @param {Blob} data The blob to encrypt\n * @param {string} version The encryption algorithm to use.  This should be set to \"x25519-xsalsa20-poly1305\" as no other algorithms are implemented right now.\n * @returns {Blob} The encrypted blob\n */\nexport function encryptWithPubKey (\n  receiverPublicKey,\n  data,\n  version\n) {\n  switch (version) {\n    case 'x25519-xsalsa20-poly1305': {\n      // generate ephemeral keypair\n      const ephemeralKeyPair = nacl.box.keyPair()\n\n      // assemble encryption parameters - from string to UInt8\n      let pubKeyUInt8Array\n      try {\n        pubKeyUInt8Array = naclUtil.decodeBase64(receiverPublicKey)\n      } catch (err) {\n        throw new Error('Bad public key')\n      }\n\n      // padding?  not needed for c decryption?\n      // const paddingBytes = new Uint8Array(32)\n      // paddingBytes.fill(0)\n      // const msgParamsUInt8Array = new Uint8Array([...paddingBytes, ...naclUtil.decodeUTF8(data)])\n      const msgParamsUInt8Array = naclUtil.decodeUTF8(data)\n      const nonce = nacl.randomBytes(nacl.box.nonceLength)\n\n      // encrypt\n      const encryptedMessage = nacl.box(\n        msgParamsUInt8Array,\n        nonce,\n        pubKeyUInt8Array,\n        ephemeralKeyPair.secretKey\n      )\n\n      // handle encrypted data\n      const output = {\n        version: 'x25519-xsalsa20-poly1305',\n        nonce: naclUtil.encodeBase64(nonce),\n        ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),\n        ciphertext: naclUtil.encodeBase64(encryptedMessage)\n      }\n      // return encrypted msg data\n      return output\n    }\n\n    default:\n      throw new Error('Encryption type/version not supported')\n  }\n}\n\n// borrowed from eth-sig-util from meatmask.\n/**\n * Decrypt a blob with a private key\n * @param {Blob} encryptedData The blob to decrypt\n * @param {string} receiverPrivateKey The base64 encoded 32 byte private key.  The corresponding public key was used to encrypt this blob\n * @param {string} version The encryption algorithm to use.  This should be set to \"x25519-xsalsa20-poly1305\" as no other algorithms are implemented right now.\n * @returns {Blob} The decrypted blob\n */\nexport function decryptWithPrivKey (\n  encryptedData,\n  receiverPrivateKey\n) {\n  switch (encryptedData.version) {\n    case 'x25519-xsalsa20-poly1305': {\n      const recieverEncryptionPrivateKey = naclUtil.decodeBase64(receiverPrivateKey)\n\n      // assemble decryption parameters\n      const nonce = naclUtil.decodeBase64(encryptedData.nonce)\n      const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext)\n      const ephemPublicKey = naclUtil.decodeBase64(\n        encryptedData.ephemPublicKey\n      )\n\n      // decrypt\n      const decryptedMessage = nacl.box.open(\n        ciphertext,\n        nonce,\n        ephemPublicKey,\n        recieverEncryptionPrivateKey\n      )\n\n      // return decrypted msg data\n      let output\n      try {\n        output = naclUtil.encodeUTF8(decryptedMessage)\n      } catch (err) {\n        throw new Error('Decryption failed.  Could not encode result as utf8')\n      }\n\n      if (output) {\n        return output\n      }\n      throw new Error('Decryption failed.  Output is falsy')\n    }\n\n    default:\n      throw new Error('Encryption type/version not supported.')\n  }\n}\n","import protons from 'protons'\n\nexport const protobufs = protons(`\nmessage Request {\n  enum Type {\n    HANDSHAKE = 0;\n    GET_KEY_FRAGMENT = 1;\n    STORE_KEY_FRAGMENT = 2;\n  }\n  required Type type = 1;\n  optional GetKeyFragment getKeyFragment = 2;\n  optional StoreKeyFragment storeKeyFragment = 3;\n  optional bytes authSig = 4;\n  optional TokenParams tokenParams = 5;\n  optional bytes clientPubKey = 6;\n  optional bytes merkleProof = 7;\n}\nmessage Response {\n  enum Type {\n    HANDSHAKE_RESPONSE = 0;\n    GET_KEY_FRAGMENT_RESPONSE = 1;\n    STORE_KEY_FRAGMENT_RESPONSE = 2;\n  }\n  required Type type = 1;\n  optional GetKeyFragmentResponse getKeyFragmentResponse = 2;\n  optional StoreKeyFragmentResponse storeKeyFragmentResponse = 3;\n  optional bytes serverPubKey = 4;\n}\nmessage GetKeyFragment {\n  required bytes keyId = 1;\n}\nmessage GetKeyFragmentResponse {\n  enum Result {\n    SUCCESS = 0;\n    NOT_FOUND = 1;\n    AUTH_FAILURE = 2;\n    ERROR = 3;\n  }\n  required Result result = 1;\n  optional bytes keyId = 2;\n  optional bytes fragmentValue = 3;\n}\nmessage StoreKeyFragment {\n  required bytes fragmentValue = 1;\n  required bytes fragmentNumber = 2;\n}\nmessage StoreKeyFragmentResponse {\n  enum Result {\n    SUCCESS = 0;\n    AUTH_FAILURE = 1;\n    ERROR = 2;\n  }\n  required Result result = 1;\n  optional bytes errorMessage = 2;\n}\nmessage TokenParams {\n  required bytes tokenAddress = 1;\n  required bytes tokenId = 2;\n  required bytes chain = 3;\n}\n`)\n\n/**\n * @typedef {Object} LITChain\n * @property {string} contractAddress - The address of the token contract\n * @property {string} chainId - The chain ID of the chain that this token contract is deployed on.  Used for EVM chains.\n * @property {string} name - The human readable name of the chain\n */\n\n/**\n * Pre-deployed token contracts that you may use for minting LITs.  These are ERC1155 contracts that let you mint any quantity of a given token.  Use the chain name as a key in this object.  Currently \"polygon\" and \"ethereum\" are supported.\n * @constant\n * @type {LITChain}\n * @default\n*/\nexport const LIT_CHAINS = {\n  polygon: {\n    contractAddress: '0xb9A323711528D0c5a70df790929f4739f1cDd7fD',\n    chainId: 137,\n    name: 'Polygon',\n    symbol: 'MATIC',\n    decimals: 18,\n    rpcUrls: ['https://rpc-mainnet.maticvigil.com'],\n    blockExplorerUrls: ['https://explorer.matic.network'],\n    balanceStorageSlot: 1,\n    type: 'ERC1155'\n  },\n  ethereum: {\n    contractAddress: '0x55485885e82E25446DEC314Ccb810Bda06B9e01B',\n    chainId: 1,\n    name: 'Ethereum',\n    symbol: 'ETH',\n    decimals: 18,\n    balanceStorageSlot: 1,\n    type: 'ERC1155'\n  },\n  kovan: {\n    contractAddress: '0xA9b2180C2A479Ba9b263878C4d81AE4e0E717846',\n    chainId: 42,\n    name: 'Ethereum',\n    symbol: 'ETH',\n    decimals: 18,\n    rpcUrls: ['https://kovan.infura.io/v3/ddf1ca3700f34497bca2bf03607fde38'],\n    blockExplorerUrls: ['https://kovan.etherscan.io'],\n    balanceStorageSlot: 1,\n    type: 'ERC20'\n  }\n}\n","import { Contract } from '@ethersproject/contracts'\nimport { verifyMessage } from '@ethersproject/wallet'\nimport { Web3Provider } from '@ethersproject/providers'\n\nimport detectEthereumProvider from '@metamask/detect-provider'\n\nimport naclUtil from 'tweetnacl-util'\nimport nacl from 'tweetnacl'\n\nimport { Header, Proof, Receipt, Transaction } from 'eth-object'\nimport { mappingAt } from 'eth-util-lite'\n\nimport LIT from '../abis/LIT.json'\nimport { LIT_CHAINS } from '../lib/constants'\n\nconst AUTH_SIGNATURE_BODY = 'I am creating an account to use LITs at {{timestamp}}'\n\nfunction chainHexIdToChainName (chainHexId) {\n  for (let i = 0; i < Object.keys(LIT_CHAINS).length; i++) {\n    const chainName = Object.keys(LIT_CHAINS)[i]\n    const litChainHexId = '0x' + LIT_CHAINS[chainName].chainId.toString('16')\n    if (litChainHexId === chainHexId) {\n      return chainName\n    }\n  }\n}\n\nexport async function connectWeb3 () {\n  if (typeof window.ethereum === 'undefined') {\n    throw new Error({ errorCode: 'no_wallet', message: 'No web3 wallet was found' })\n  }\n\n  const provider = await detectEthereumProvider()\n\n  // trigger metamask popup\n  const accounts = await provider.request({ method: 'eth_requestAccounts' })\n  const account = accounts[0].toLowerCase()\n\n  return { web3: provider, account }\n}\n\n// taken from the excellent repo https://github.com/zmitton/eth-proof\nexport async function getMerkleProof ({ tokenAddress, balanceStorageSlot, tokenId }) {\n  console.log(`getMerkleProof for { tokenAddress, balanceStorageSlot, tokenId } ${tokenAddress}, ${balanceStorageSlot}, ${tokenId}`)\n  const { web3, account } = await connectWeb3()\n  console.log(`getting mappingAt(${balanceStorageSlot}, ${tokenId}, ${account})`)\n  const storageAddress = mappingAt(balanceStorageSlot, parseInt(tokenId), account)\n  console.log('storageAddress: ', storageAddress)\n  const rpcBlock = await web3.request({ method: 'eth_getBlockByNumber', params: ['latest', false] })\n  console.log('rpcBlock: ', rpcBlock)\n  // const rpcProof = await web3.eth.getProof(tokenAddress, [storageAddress], rpcBlock.number)\n  const rpcProof = await web3.request({ method: 'eth_getProof', params: [tokenAddress, [storageAddress], rpcBlock.number] })\n  console.log('rpcProof: ', rpcProof)\n\n  return {\n    header: rpcBlock,\n    accountProof: rpcProof.accountProof,\n    storageProof: rpcProof.storageProof[0].proof,\n    blockHash: rpcBlock.hash\n  }\n}\n\n// export async function checkAndDeriveKeypair () {\n//   let keypair = localStorage.getItem('lit-keypair')\n//   if (!keypair) {\n//     await deriveEncryptionKeys()\n//     keypair = localStorage.getItem('lit-keypair')\n//   }\n//   keypair = JSON.parse(keypair)\n//   const { web3, account } = await connectWeb3()\n//   // make sure we are on the right account\n//   if (account !== keypair.address) {\n//     await deriveEncryptionKeys()\n//     keypair = localStorage.getItem('lit-keypair')\n//     keypair = JSON.parse(keypair)\n//   }\n//   return keypair\n// }\n\n/**\n * Check for an existing cryptographic authentication signature and create one of it does not exist.  This is used to prove ownership of a given crypto wallet address to the LIT nodes.  The result is stored in LocalStorage so the user doesn't have to sign every time they perform an operation.\n * @param {Object} params\n * @param {string} params.chain The chain you want to use.  \"polygon\" and \"ethereum\" are currently supported.\n * @returns {AuthSig} The AuthSig created or retrieved\n */\nexport async function checkAndSignAuthMessage ({ chain }) {\n  const { web3, account } = await connectWeb3()\n  const chainId = await web3.request({ method: 'eth_chainId', params: [] })\n  const selectedChain = LIT_CHAINS[chain]\n  const selectedChainId = '0x' + selectedChain.chainId.toString('16')\n  console.debug(`checkAndSignAuthMessage with chainId ${chainId} and chain set to ${chain} and selectedChain is `, selectedChain)\n  if (chainId !== selectedChainId) {\n    // the metamask chain switching thing does not work on mainnet\n    if (selectedChain.chainId !== 1) {\n      const data = [{\n        chainId: selectedChainId,\n        chainName: selectedChain.name,\n        nativeCurrency:\n                {\n                  name: selectedChain.name,\n                  symbol: selectedChain.symbol,\n                  decimals: selectedChain.decimals\n                },\n        rpcUrls: selectedChain.rpcUrls,\n        blockExplorerUrls: selectedChain.blockExplorerUrls\n      }]\n      const res = await web3.request({ method: 'wallet_addEthereumChain', params: data }).catch()\n      if (res) {\n        console.log(res)\n      }\n    } else {\n      return { errorCode: 'wrong_chain' }\n    }\n  }\n  let authSig = localStorage.getItem('lit-auth-signature')\n  if (!authSig) {\n    await signAndSaveAuthMessage()\n    authSig = localStorage.getItem('lit-auth-signature')\n  }\n  authSig = JSON.parse(authSig)\n  // make sure we are on the right account\n  if (account !== authSig.address) {\n    await signAndSaveAuthMessage()\n    authSig = localStorage.getItem('lit-auth-signature')\n    authSig = JSON.parse(authSig)\n  }\n  return authSig\n}\n\nexport async function signAndSaveAuthMessage () {\n  const now = (new Date()).toISOString()\n  const body = AUTH_SIGNATURE_BODY.replace('{{timestamp}}', now)\n  const signedResult = await signMessage({ body })\n  localStorage.setItem('lit-auth-signature', JSON.stringify({\n    sig: signedResult.signature,\n    derivedVia: 'web3.eth.personal.sign',\n    signedMessage: body,\n    address: signedResult.address\n  }))\n  // store a keypair in localstorage for communication with sgx\n  const commsKeyPair = nacl.box.keyPair()\n  localStorage.setItem('lit-comms-keypair', JSON.stringify({\n    publicKey: naclUtil.encodeBase64(commsKeyPair.publicKey),\n    secretKey: naclUtil.encodeBase64(commsKeyPair.secretKey)\n  }))\n  console.log('generated and saved lit-comms-keypair')\n}\n\n/**\n * @typedef {Object} AuthSig\n * @property {string} sig - The actual hex-encoded signature\n * @property {string} derivedVia - The method used to derive the signature\n * @property {string} signedMessage - The message that was signed\n * @property {string} address - The crypto wallet address that signed the message\n */\nexport async function signMessage ({ body }) {\n  const { web3, account } = await connectWeb3()\n\n  console.log('signing with ', account)\n  const signature = await web3.request({ method: 'personal_sign', params: [account, body] })\n  const address = verifyMessage(body, signature).toLowerCase()\n\n  console.log('Signature: ', signature)\n  console.log('recovered address: ', address)\n\n  if (address !== account) {\n    const msg = `ruh roh, the user signed with a different address (${address}) then they\\'re using with web3 (${account}).  this will lead to confusion.`\n    console.error(msg)\n    alert('something seems to be wrong with your wallets message signing.  maybe restart your browser or your wallet.  your recovered sig address does not match your web3 account address')\n    throw new Error(msg)\n  }\n\n  return { signature, address }\n}\n\n// export async function decryptWithWeb3PrivateKey (encryptedData) {\n//   const { web3, account } = await connectWeb3()\n//   try {\n//     const decryptedMessage = ethereum\n//       .request({\n//         method: 'eth_decrypt',\n//         params: [encryptedData, account]\n//       })\n//     return decryptedMessage\n//   } catch (error) {\n//     console.log(error)\n//     return false\n//   }\n// }\n//\n// async function deriveKeysViaSignature () {\n//   const { signature, address } = await signMessage({ body: KEY_DERIVATION_SIGNATURE_BODY })\n//   console.log('Signed message: ' + signature)\n//\n//   // derive keypair\n//   const data = Buffer.from(signature.substring(2), 'hex')\n//   const hash = await crypto.subtle.digest('SHA-256', data)\n//   const uint8Hash = new Uint8Array(hash)\n//   const { publicKey, secretKey } = nacl.box.keyPair.fromSecretKey(uint8Hash)\n//   return {\n//     publicKey: naclUtil.encodeBase64(publicKey),\n//     secretKey: naclUtil.encodeBase64(secretKey)\n//   }\n// }\n//\n// // this only works on metamask :(\n// async function deriveKeysViaPrivateKey () {\n//   try {\n//     const { web3, account } = await connectWeb3()\n//     /* global ethereum */\n//     /* eslint no-undef: \"error\" */\n//     const publicKey = await ethereum\n//       .request({\n//         method: 'eth_getEncryptionPublicKey',\n//         params: [account] // you must have access to the specified account\n//       })\n//     return { publicKey }\n//   } catch (error) {\n//     console.log(error)\n//     if (error.code === 4001) {\n//       // EIP-1193 userRejectedRequest error\n//       console.log(\"We can't encrypt anything without the key.\")\n//       error('You must accept the metamask request to derive your public encryption key')\n//     } else {\n//       console.error(error)\n//     }\n//     return { error }\n//   }\n// }\n//\n// export async function deriveEncryptionKeys () {\n//   let keypair = {}\n//   // key derivation via metamask is more desirable because then even this SDK can't see the secret key :-D\n//   const { error, publicKey } = await deriveKeysViaPrivateKey()\n//   if (!error) {\n//     keypair = {\n//       publicKey,\n//       derivedVia: 'eth_getEncryptionPublicKey'\n//     }\n//   } else {\n//     const { publicKey, secretKey } = await deriveKeysViaSignature()\n//     keypair = {\n//       publicKey,\n//       secretKey,\n//       derivedVia: 'web3.eth.personal.sign',\n//       signedMessage: KEY_DERIVATION_SIGNATURE_BODY\n//     }\n//   }\n//\n//   const { web3, account } = await connectWeb3()\n//   keypair.address = account\n//\n//   console.log('public key: ' + keypair.publicKey)\n//   const asString = JSON.stringify(keypair)\n//   localStorage.setItem('lit-keypair', asString)\n//\n//   // is it already saved on the server?\n//   const { pubkey, errorCode } = await getPublicKey({\n//     address: account\n//   })\n//   if (errorCode === 'not_found' || pubkey !== keypair.publicKey) {\n//     // add it\n//     const msg = `I am saving my public key so that others can send me LITs.  It is ${pubkey}`\n//     const res = await signMessage({ body: msg })\n//     await savePublicKey({\n//       sig: res.signature,\n//       msg,\n//       pubkey: keypair.publicKey\n//     })\n//   }\n// }\n\n/**\n * This function mints a LIT using our pre-deployed token contracts.  You may our contracts, or you may supply your own.  Our contracts are ERC1155 tokens on Polygon and Ethereum.  Using these contracts is the easiest way to get started.\n * @param {Object} params\n * @param {string} params.chain The chain to mint on.  \"ethereum\" and \"polygon\" are currently supported.\n * @param {number} params.quantity The number of tokens to mint.  Note that these will be fungible, so they will not have serial numbers.\n * @returns {Object} The txHash, tokenId, tokenAddress, mintingAddress, and authSig.\n */\nexport async function mintLIT ({ chain, quantity }) {\n  console.log(`minting ${quantity} tokens on ${chain}`)\n  try {\n    const authSig = await checkAndSignAuthMessage({ chain })\n    if (authSig.errorCode) {\n      return authSig\n    }\n    const { web3, account } = await connectWeb3()\n    const tokenAddress = LIT_CHAINS[chain].contractAddress\n    const contract = new Contract(tokenAddress, LIT.abi, new Web3Provider(web3).getSigner())\n    console.log('sending to chain...')\n    const tx = await contract.mint(quantity)\n    console.log('sent to chain.  waiting to be mined...')\n    const txReceipt = await tx.wait()\n    console.log('txReceipt: ', txReceipt)\n    const tokenId = txReceipt.events[0].args[3].toNumber()\n    return {\n      txHash: txReceipt.transactionHash,\n      tokenId,\n      tokenAddress,\n      mintingAddress: account,\n      authSig\n    }\n  } catch (error) {\n    console.log(error)\n    if (error.code === 4001) {\n      // EIP-1193 userRejectedRequest error\n      console.log('User rejected request')\n      return { errorCode: 'user_rejected_request' }\n    } else {\n      console.error(error)\n    }\n    return { errorCode: 'unknown_error' }\n  }\n}\n\n/**\n * Finds the tokens that the current user owns from the predeployed LIT contracts\n * @param {Object} params\n * @param {string} params.chain The chain that was minted on. \"ethereum\" and \"polygon\" are currently supported.\n * @param {number} params.accountAddress The account address to check\n * @returns {array} The token ids owned by the accountAddress\n */\nexport async function findLITs () {\n  console.log('findLITs')\n\n  try {\n    const { web3, account } = await connectWeb3()\n    const chainHexId = await web3.request({ method: 'eth_chainId', params: [] })\n    const chain = chainHexIdToChainName(chainHexId)\n    const tokenAddress = LIT_CHAINS[chain].contractAddress\n    const contract = new Contract(tokenAddress, LIT.abi, new Web3Provider(web3).getSigner())\n    console.log('getting maxTokenid')\n    const maxTokenId = await contract.tokenIds()\n    const accounts = []\n    const tokenIds = []\n    for (let i = 0; i <= maxTokenId; i++) {\n      accounts.push(account)\n      tokenIds.push(i)\n    }\n    console.log('getting balanceOfBatch')\n    const balances = await contract.balanceOfBatch(accounts, tokenIds)\n    // console.log('balances', balances)\n    const tokenIdsWithNonzeroBalances = balances.map((b, i) => b.toNumber() === 0 ? null : i).filter(b => b !== null)\n    return { tokenIds: tokenIdsWithNonzeroBalances, chain }\n  } catch (error) {\n    console.log(error)\n    if (error.code === 4001) {\n      // EIP-1193 userRejectedRequest error\n      console.log('User rejected request')\n      return { errorCode: 'user_rejected_request' }\n    } else {\n      console.error(error)\n    }\n    return { errorCode: 'unknown_error' }\n  }\n}\n\n/**\n * Send a token to another account\n * @param {Object} params\n * @param {string} params.tokenMetadata The token metadata of the token to be transferred.  Should include tokenId, tokenAddress, and chain\n * @param {number} params.to The account address to send the token to\n * @returns {Object} Success or error\n */\nexport async function sendLIT ({ tokenMetadata, to }) {\n  console.log('sendLIT for ', tokenMetadata)\n\n  try {\n    const { web3, account } = await connectWeb3()\n    const { tokenAddress, tokenId, chain } = tokenMetadata\n    const contract = new Contract(tokenAddress, LIT.abi, new Web3Provider(web3).getSigner())\n    console.log('transferring')\n    const maxTokenId = await contract.safeTransferFrom(account, to, tokenId, 1, [])\n    console.log('sent to chain')\n    return { success: true }\n  } catch (error) {\n    console.log(error)\n    if (error.code === 4001) {\n      // EIP-1193 userRejectedRequest error\n      console.log('User rejected request')\n      return { errorCode: 'user_rejected_request' }\n    } else {\n      console.error(error)\n    }\n    return { errorCode: 'unknown_error' }\n  }\n}\n","import { checkAndSignAuthMessage, getMerkleProof } from './eth'\nimport { LIT_CHAINS } from '../lib/constants'\n\nexport const listenForChildFrameMessages = async () => {\n  console.log('calling listenForChildFrameMessages from ' + window.origin)\n  // listen for requests from child frames\n  window.addEventListener('message', async (event) => {\n    // console.log('onMessage in sdk: ', event)\n\n    let childFrameThatSentMessageIndex = false\n    for (let i = 0; i < frames.length; i++) {\n      if (frames[i] === event.source) {\n        childFrameThatSentMessageIndex = i\n      }\n    }\n\n    if (childFrameThatSentMessageIndex !== false) {\n      console.log('onMessage in parent: ', event)\n\n      const { command, params } = event.data\n      if (command === 'LIT_SYN') {\n        window.frames[childFrameThatSentMessageIndex].postMessage({ response: 'LIT_ACK' }, '*')\n        return\n      }\n      //       if (command === 'signAndGetEncryptionKey') {\n      //         authSig = await checkAndSignAuthMessage({ chain: params.chain })\n      //         if (authSig.errorCode && authSig.errorCode === 'wrong_chain') {\n      //           alert('You are connected to the wrong blockchain.  Please switch your metamask to ' + params.chain)\n      //         }\n      //\n      //         // get the merkle proof\n      //         const { balanceStorageSlot } = LIT_CHAINS[params.chain]\n      //         try {\n      //           merkleProof = await getMerkleProof({ tokenAddress: params.tokenAddress, balanceStorageSlot, tokenId: params.tokenId })\n      //         } catch (e) {\n      //           console.log(e)\n      //           alert('Error - could not obtain merkle proof.  Some nodes do not support this operation yet.  Please try another ETH node.')\n      //           return\n      //         }\n      //         const encryptionKey = await window.litNodeClient.getEncryptionKey({\n      //           ...params, authSig, merkleProof\n      //         })\n      //         window.frames[childFrameThatSentMessageIndex].postMessage({ respondingToCommand: command, encryptionKey }, '*')\n      //         return\n      //       }\n      if (event.data.target === 'LitNodeClient') {\n        // forward this on to the nodes\n        if (command === 'getEncryptionKey') {\n          const encryptionKey = await window.litNodeClient.getEncryptionKey({\n            ...params\n          })\n          window.frames[childFrameThatSentMessageIndex].postMessage({ respondingToCommand: command, encryptionKey }, '*')\n        }\n      }\n    }\n  }, false)\n}\n\nexport const listenForFrameParentMessages = async () => {\n  console.log('calling listenForFrameParentMessages from ' + window.origin)\n  // listen for requests from child frames\n  window.addEventListener('message', async (event) => {\n    const messageIsFromFrameParent = event.source === window.parent\n\n    if (messageIsFromFrameParent) {\n      console.log('onMessage in frame: ', event)\n    }\n\n    // console.log('messageIsFromFrameParent: ', messageIsFromFrameParent)\n\n    if (messageIsFromFrameParent) {\n      const { response, respondingToCommand } = event.data\n      if (response === 'LIT_ACK') {\n        window.useLitPostMessageProxy = true\n        return\n      }\n      if (respondingToCommand === 'getEncryptionKey') {\n        const { encryptionKey } = event.data\n        LitJsSdk.default.toggleLock({ encryptionKeyFromParentFrame: encryptionKey })\n      }\n    }\n  }, false)\n}\n\nexport const sendMessageToFrameParent = (data) => {\n  window.parent.postMessage(data, '*')\n}\n\nexport const inIframe = () => {\n  try {\n    return window.self !== window.top\n  } catch (e) {\n    return true\n  }\n}\n","/**\n * Convert a file to a data URL, which could then be embedded in a LIT.  A data URL is a string representation of a file.\n * @param {File} file The file to turn into a data url\n * @returns {string} The data URL.  This is a string representation that can be used anywhere the original file would be used.\n */\nexport function fileToDataUrl (file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader()\n    reader.onloadend = () => {\n      resolve(reader.result)\n    }\n    reader.readAsDataURL(file)\n  })\n}\n","import JSZip from 'jszip'\n\nimport {\n  importSymmetricKey,\n  generateSymmetricKey,\n  encryptWithSymmetricKey,\n  decryptWithSymmetricKey,\n  compareArrayBuffers\n} from './crypto'\n\nimport {\n  checkAndSignAuthMessage,\n  getMerkleProof\n} from './eth'\n\nimport {\n  sendMessageToFrameParent\n} from './frameComms'\n\nimport { fileToDataUrl } from './browser'\nimport { LIT_CHAINS } from '../lib/constants'\n\nconst PACKAGE_CACHE = {}\n\n/**\n * Zip and encrypt a string.  This is used to encrypt any string that is to be locked and included in a LIT.  For example, on MintLIT, we render the HTML/CSS containing the locked files and a grid to view them to a string using ReactDOMServer.renderToString().\n * @param {string} string The string to zip and encrypt\n * @returns {Object} The encryptedZip as a Blob and the symmetricKey used to encrypt it, as a JSON string.  The encrypted zip will contain a single file called \"string.txt\"\n */\nexport async function zipAndEncryptString (string) {\n  const zip = new JSZip()\n  zip.file('string.txt', string)\n  return encryptZip(zip)\n}\n\n/**\n * Zip and encrypt multiple files.\n * @param {array} files An array of the files you wish to zip and encrypt\n * @returns {Object} The encryptedZip as a Blob and the symmetricKey used to encrypt it, as a JSON string.  The encrypted zip will contain a folder \"encryptedAssets\" and all of the files will be inside it.\n */\nexport async function zipAndEncryptFiles (files) {\n  // let's zip em\n  const zip = new JSZip()\n  for (let i = 0; i < files.length; i++) {\n    zip.folder('encryptedAssets').file(files[i].name, files[i])\n  }\n  return encryptZip(zip)\n}\n\n/**\n * Decrypt and unzip a zip that was created using encryptZip, zipAndEncryptString, or zipAndEncryptFiles.\n * @param {Blob} encryptedZipBlob The encrypted zip as a Blob\n * @param {Object} symmKey An object containing the symmetric key used that will be used to decrypt this zip.\n * @returns {Array} An array of the decrypted files inside the zip.\n */\nexport async function decryptZip (encryptedZipBlob, symmKey) {\n  // const keypair = await checkAndDeriveKeypair()\n\n  // console.log('Got keypair out of localstorage: ' + keypair)\n  // const privkey = keypair.secretKey\n\n  // let decryptedSymmKey = await decryptWithWeb3PrivateKey(symmKey)\n  // if (!decryptedSymmKey) {\n  //   // fallback to trying the private derived via signature\n  //   console.log('probably not metamask')\n  //   decryptedSymmKey = decryptWithPrivkey(symmKey, privkey)\n  // }\n  // console.log('decrypted', decryptedSymmKey)\n\n  // import the decrypted symm key\n  const importedSymmKey = await importSymmetricKey(symmKey)\n\n  const decryptedZipArrayBuffer = await decryptWithSymmetricKey(\n    encryptedZipBlob,\n    importedSymmKey\n  )\n\n  // unpack the zip\n  const zip = new JSZip()\n  const unzipped = await zip.loadAsync(decryptedZipArrayBuffer)\n\n  // load the files into data urls with the metadata attached\n  // const files = await Promise.all(unzipped.files.map(async f => {\n  //   // const dataUrl = await fileToDataUrl(f)\n  //   return {\n  //     type: f.type,\n  //     name: f.name,\n  //     file: f\n  //   }\n  // }))\n\n  return unzipped.files\n}\n\n/**\n * Encrypt a zip file created with JSZip using a new random symmetric key via WebCrypto.\n * @param {JSZip} zip The JSZip instance to encrypt\n * @returns {Object} The encryptedZip as a Blob and the symmetricKey used to encrypt it, as a JSON string.\n */\nexport async function encryptZip (zip) {\n  const zipBlob = await zip.generateAsync({ type: 'blob' })\n  const zipBlobArrayBuffer = await zipBlob.arrayBuffer()\n  console.log('blob', zipBlob)\n\n  const symmKey = await generateSymmetricKey()\n  const encryptedZipBlob = await encryptWithSymmetricKey(\n    symmKey,\n    zipBlobArrayBuffer\n  )\n\n  // to download the encrypted zip file for testing, uncomment this\n  // saveAs(encryptedZipBlob, 'encrypted.bin')\n\n  const exportedSymmKey = await crypto.subtle.exportKey('jwk', symmKey)\n  console.log('exportedSymmKey', exportedSymmKey)\n\n  // encrypt the symmetric key with the\n  // public key derived from the eth wallet\n  // const keypair = await checkAndDeriveKeypair()\n  // const pubkey = keypair.publicKey\n  // const privkey = keypair.secretKey\n\n  // encrypt symm key\n  // const encryptedSymmKeyData = encryptWithPubkey(pubkey, JSON.stringify(exportedSymmKey), 'x25519-xsalsa20-poly1305')\n  // const packed = JSON.stringify(encryptedSymmKeyData)\n\n  //   console.log('packed symmetric key ', packed)\n  //   const unpacked = JSON.parse(packed)\n  //   // test decrypt\n  //   const decryptedSymmKey = decryptWithPrivkey(unpacked, privkey)\n  //   console.log('decrypted', decryptedSymmKey)\n  //\n  //   // import the decrypted symm key\n  //   const importedSymmKey = await importSymmetricKey(decryptedSymmKey)\n  //\n  //   const decryptedZipArrayBuffer = await decryptWithSymmetricKey(\n  //     encryptedZipBlob,\n  //     importedSymmKey\n  //   )\n  //\n  //   // compare zip before and after as a sanity check\n  //   const isEqual = compareArrayBuffers(\n  //     zipBlobArrayBuffer,\n  //     decryptedZipArrayBuffer\n  //   )\n  //   console.log('Zip before and after decryption are equal: ', isEqual)\n  //   if (!isEqual) {\n  //     throw new Error('Decrypted zip does not match original zip.  Something is wrong.')\n  //   }\n\n  // to download the zip, for testing, uncomment this\n  //   const decryptedBlob = new Blob(\n  //     [decryptedZipArrayBuffer],\n  //     { type: 'application/zip' }\n  //   )\n  //   console.log('decrypted blob', decryptedBlob)\n  //\n  //   saveAs(decryptedBlob, 'decrypted.zip')\n  // console.log('saved')\n\n  return {\n    symmetricKey: JSON.stringify(exportedSymmKey),\n    encryptedZip: encryptedZipBlob\n  }\n}\n\nasync function getNpmPackage (packageName) {\n  // console.log('getting npm package: ' + packageName)\n  if (PACKAGE_CACHE[packageName]) {\n    // console.log('found in cache')\n    return PACKAGE_CACHE[packageName]\n  }\n\n  const resp = await fetch('https://unpkg.com/' + packageName)\n  if (!resp.ok) {\n    console.log('error with response: ', resp)\n    throw Error(resp.statusText)\n  }\n  const blob = await resp.blob()\n  // console.log('got blob', blob)\n  const dataUrl = await fileToDataUrl(blob)\n  // console.log('got dataUrl', dataUrl)\n  PACKAGE_CACHE[packageName] = dataUrl\n  return dataUrl\n}\n\n/**\n * Create a ready-to-go LIT using provided HTML/CSS body and an encrypted zip data url.  You need to design your LIT with HTML and CSS, and provide an unlock button with the id \"unlockButton\" inside your HTML.  This function will handle the rest.\n * @param {Object} params\n * @param {string} params.title The title that will be used for the title tag in the outputted HTML\n * @param {number} params.htmlBody The HTML body for the locked state of the LIT.  All users will be able to see this HTML.  This HTML must have a button with an id of \"unlockButton\" which will be automatically set up to decrypt and load the encryptedZipDataUrl\n * @param {string} params.css Any CSS you would like to include in the outputted HTML\n * @param {number} params.encryptedZipDataUrl a data URL of the encrypted zip that contains the locked content that only token holders will be able to view.\n * @param {string} params.tokenAddress The token address of the corresponding NFT for this LIT.  ERC721 and ERC 1155 tokens are currently supported.\n * @param {number} params.tokenId The ID of the token of the corresponding NFT for this LIT.  Only holders of this token ID will be able to unlock and decrypt this LIT.\n * @param {string} params.chain The chain that the corresponding NFT was minted on.  \"ethereum\" and \"polygon\" are currently supported.\n * @param {Array} [params.npmPackages=[]] An array of strings of NPM package names that should be embedded into this LIT.  These packages will be pulled down via unpkg, converted to data URLs, and embedded in the LIT HTML.  You can include any packages from npmjs.com.\n * @returns {string} The HTML string that is now a LIT.  You can send this HTML around and only token holders will be able to unlock and decrypt the content inside it.  Included in the HTML is this LIT JS SDK itself, the encrypted locked content, an automatic connection to the LIT nodes network, and a handler for a button with id \"unlockButton\" which will perform the unlock operation when clicked.\n */\nexport async function createHtmlLIT ({\n  title,\n  htmlBody,\n  css,\n  encryptedZipDataUrl,\n  tokenAddress,\n  tokenId,\n  chain,\n  npmPackages = []\n}) {\n  // uncomment this to embed the LIT JS SDK directly instead of retrieving it from unpkg when a user views the LIT\n  // npmPackages.push('lit-js-sdk')\n  // console.log('createHtmlLIT with npmPackages', npmPackages)\n  let scriptTags = ''\n  for (let i = 0; i < npmPackages.length; i++) {\n    const scriptDataUrl = await getNpmPackage(npmPackages[i])\n    const tag = `<script src=\"${scriptDataUrl}\"></script>\\n`\n    scriptTags += tag\n  }\n\n  // console.log('scriptTags: ', scriptTags)\n\n  return `\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>${title}</title>\n    <style id=\"jss-server-side\">${css}</style>\n    ${scriptTags}\n    <script>\n      var encryptedZipDataUrl = \"${encryptedZipDataUrl}\"\n      var tokenAddress = \"${tokenAddress}\"\n      var tokenId = \"${tokenId}\"\n      var chain = \"${chain}\"\n      var locked = true\n      var useLitPostMessageProxy = false\n    </script>\n    <script onload='LitJsSdk.default.litJsSdkLoadedInALIT()' src=\"https://cdn.jsdelivr.net/npm/lit-js-sdk@1.1/build/index.web.js\"></script>\n  </head>\n  <body>\n    <div id=\"root\">${htmlBody}</div>\n    <script>\n      const unlockButton = document.getElementById('unlockButton')\n      unlockButton.onclick = function() {\n        LitJsSdk.default.toggleLock()\n      }\n    </script>\n  </body>\n</html>\n  `\n}\n\n/**\n * Lock and unlock the encrypted content inside a LIT.  This content is only viewable by holders of the NFT that corresponds to this LIT.  Locked content will be decrypted and placed into the HTML element with id \"mediaGridHolder\".  The HTML element with the id \"lockedHeader\" will have it's text automatically changed to LOCKED or UNLOCKED to denote the state of the LIT.  Note that if you're creating a LIT using the createHtmlLIT function, you do not need to use this function, because this function is automatically bound to any button in your HTML with the id \"unlockButton\".\n */\nexport async function toggleLock () {\n  const mediaGridHolder = document.getElementById('mediaGridHolder')\n  const lockedHeader = document.getElementById('lockedHeader')\n\n  if (window.locked) {\n    // save public content before decryption, so we can toggle back to the\n    // locked state in the future\n    window.publicContent = mediaGridHolder.innerHTML\n\n    if (!window.litNodeClient.ready && !window.useLitPostMessageProxy) {\n      alert('The LIT network is still connecting.  Please try again in about 10 seconds.')\n      return\n    }\n\n    const authSig = await checkAndSignAuthMessage({ chain: window.chain })\n    if (authSig.errorCode && authSig.errorCode === 'wrong_chain') {\n      alert('You are connected to the wrong blockchain.  Please switch your metamask to ' + window.chain)\n      return\n    }\n\n    // get the merkle proof\n    const { balanceStorageSlot } = LIT_CHAINS[window.chain]\n    let merkleProof = null\n    try {\n      merkleProof = await getMerkleProof({ tokenAddress: window.tokenAddress, balanceStorageSlot, tokenId: window.tokenId })\n    } catch (e) {\n      console.log(e)\n      alert('Error - could not obtain merkle proof.  Some nodes do not support this operation yet.  Please try another ETH node.')\n      return\n    }\n\n    if (window.useLitPostMessageProxy) {\n      // instead of asking the network for the key part, ask the parent frame\n      // the parentframe will then call unlockLit() with the encryption key\n      sendMessageToFrameParent({ command: 'getEncryptionKey', target: 'LitNodeClient', params: { tokenAddress: window.tokenAddress, tokenId: window.tokenId, chain: window.chain, authSig, merkleProof } })\n      return\n    }\n\n    // get the encryption key\n    const symmetricKey = await window.litNodeClient.getEncryptionKey({\n      tokenAddress: window.tokenAddress,\n      tokenId: window.tokenId,\n      authSig,\n      chain: window.chain,\n      merkleProof\n    })\n\n    await unlockLitWithKey({ symmetricKey })\n  } else {\n    mediaGridHolder.innerHTML = window.publicContent\n    lockedHeader.innerText = 'LOCKED'\n    window.locked = true\n  }\n}\n\nasync function unlockLitWithKey ({ symmetricKey }) {\n  const mediaGridHolder = document.getElementById('mediaGridHolder')\n  const lockedHeader = document.getElementById('lockedHeader')\n\n  // convert data url to blob\n  const encryptedZipBlob = await (await fetch(window.encryptedZipDataUrl)).blob()\n  const decryptedFiles = await decryptZip(encryptedZipBlob, symmetricKey)\n  const mediaGridHtmlBody = await decryptedFiles['string.txt'].async('text')\n  mediaGridHolder.innerHTML = mediaGridHtmlBody\n  lockedHeader.innerText = 'UNLOCKED'\n  window.locked = false\n}\n","import multihashing from 'multihashing'\nimport CID from 'cids'\n\nexport const kFragKey = ({ tokenAddress, tokenId, chain }) => {\n  const normalizedTokenAddress = tokenAddress.toLowerCase()\n  const normalizedTokenId = parseInt(tokenId).toString(16).padStart(64, '0') // to hex and padded for consistent length\n  const formattedKey = `${normalizedTokenAddress}|${normalizedTokenId}|${chain}`\n  const hashed = multihashing(Buffer.from(formattedKey), 'sha2-256')\n  const cid = new CID(hashed)\n  return cid.toString()\n}\n","// import 'babel-polyfill'\nimport Libp2p from 'libp2p'\nimport Websockets from 'libp2p-websockets'\nimport WebRTCDirect from '@lit-protocol/libp2p-webrtc-direct'\nimport { NOISE } from 'libp2p-noise'\nimport Mplex from 'libp2p-mplex'\nimport KadDHT from 'libp2p-kad-dht'\nimport PeerId from 'peer-id'\nimport { multiaddr } from 'multiaddr'\nimport Bootstrap from 'libp2p-bootstrap'\nimport pipe from 'it-pipe'\nimport lp from 'it-length-prefixed'\nimport multihashing from 'multihashing'\nimport CID from 'cids'\nimport pushable from 'it-pushable'\nimport secrets from 'secrets.js-lit'\nimport uint8arrayFromString from 'uint8arrays/from-string'\nimport uint8arrayToString from 'uint8arrays/to-string'\nimport all from 'it-all'\nimport naclUtil from 'tweetnacl-util'\n\nimport { protobufs } from '../lib/constants'\nimport { kFragKey } from '../lib/utils'\nimport { encryptWithPubKey, decryptWithPrivKey } from './crypto'\n\nconst { Request, Response, StoreKeyFragmentResponse, GetKeyFragmentResponse } = protobufs\n\n/**\n * A LIT node client.  Connects directly to the LIT nodes to store and retrieve encryption keys.  Only holders of an NFT that corresponds with a LIT may store and retrieve the keys.\n * @param {Object} config\n * @param {boolean} [config.alertWhenUnauthorized=true] Whether or not to show a JS alert() when a user tries to unlock a LIT but is unauthorized.  If you turn this off, you should create an event listener for the \"lit-authFailure\" event on the document, and show your own error to the user.\n * @param {number} [config.minNodeCount=8] The minimum number of nodes that must be connected for the LitNodeClient to be ready to use.\n */\nexport default class LitNodeClient {\n  constructor (\n    config = {\n      alertWhenUnauthorized: true,\n      minNodeCount: 8,\n      bootstrapUrls: ['/dns4/node1.litgateway.com/tcp/9090/https/p2p-webrtc-direct/p2p/12D3KooWK1KtaAV5rWjbAmZcd62VYSmEz1k81jzr87JAcSS7rKdQ']\n    }\n  ) {\n    this.config = config\n    this.libp2p = null\n    this.connectedNodes = new Set()\n    this.serverPubKeys = {}\n    this.ready = false\n  }\n\n  /**\n   * Retrieve the symmetric encryption key from the LIT nodes.  Note that this will only work if the current user is a holder of the NFT that corresponds to this LIT.  This NFT token address and ID was specified when this LIT was created.\n   * @param {Object} params\n   * @param {string} params.tokenAddress The token address of the NFT that corresponds to this LIT.  This should be an ERC721 or ERC1155 token.\n   * @param {string} params.tokenId The token ID of the NFT that corresponds to this LIT\n  * @param {string} params.chain The chain that the corresponding NFT lives on.  Currently \"polygon\" and \"ethereum\" are supported.\n   * @param {AuthSig} params.authSig The authentication signature that proves that the user owns the crypto wallet address that should be an owner of the NFT that corresponds to this LIT.\n   * @returns {Object} The symmetric encryption key that can be used to decrypt the locked content inside the LIT.  You should pass this key to the decryptZip function.\n  */\n  async getEncryptionKey ({ tokenAddress, tokenId, chain, authSig, merkleProof }) {\n    const encryptedKFrags = await this.getEncryptionKeyFragments({ tokenAddress, tokenId, authSig, chain, merkleProof })\n    if (encryptedKFrags.some(k => k === 'AUTH_FAILURE')) {\n      if (this.config.alertWhenUnauthorized) {\n        alert('You are not authorized to unlock to this LIT')\n      }\n      document.dispatchEvent(new Event('lit-authFailure'))\n      return null\n    }\n    const commsKeypair = JSON.parse(localStorage.getItem('lit-comms-keypair'))\n    // decrypt kfrags\n    const kFrags = []\n    for (let i = 0; i < encryptedKFrags.length; i++) {\n      const decrypted = decryptWithPrivKey(JSON.parse(encryptedKFrags[i]), commsKeypair.secretKey)\n      kFrags.push(decrypted)\n    }\n    const secret = secrets.combine(kFrags)\n    const symmetricKey = uint8arrayToString(uint8arrayFromString(secret, 'base16'))\n    return symmetricKey\n  }\n\n  /**\n * Securely save the symmetric encryption key to the LIT nodes.\n * @param {Object} params\n * @param {string} params.tokenAddress The token address of the NFT that corresponds to this LIT.  This should be an ERC721 or ERC1155 token.\n * @param {string} params.tokenId The token ID of the NFT that corresponds to this LIT\n * @param {string} params.chain The chain that the corresponding NFT lives on.  Currently \"polygon\" and \"ethereum\" are supported.\n * @param {AuthSig} params.authSig The authentication signature that proves that the user owns the crypto wallet address that should be an owner of the NFT that corresponds to this LIT.\n * @param {string} params.symmetricKey The symmetric encryption key that was used to encrypt the locked content inside the LIT.  You should use zipAndEncryptString or zipAndEncryptFiles to get this encryption key.  This key will be split up using threshold encryption so that the LIT nodes cannot decrypt a given LIT.\n * @returns {Object} An object that gives the status of the operation, denoted via a boolean with the key \"success\"\n */\n  async saveEncryptionKey ({ tokenAddress, tokenId, chain, authSig, symmetricKey, merkleProof }) {\n    // console.log(`saveEncryptionKey with tokenAddress ${tokenAddress} and tokenId ${tokenId} and symmetricKey ${symmetricKey} and authSig ${authSig} and chain ${chain}`)\n    const nodes = Array.from(this.connectedNodes)\n    // split up into nodes.length fragments\n    const numShares = nodes.length\n    const threshold = Math.floor(numShares / 2)\n    // convert from base64 to hex\n    const secret = uint8arrayToString(uint8arrayFromString(symmetricKey), 'base16')\n    console.debug(`splitting up into ${numShares} shares with a threshold of ${threshold}`)\n    const kFrags = secrets.share(secret, numShares, threshold)\n    if (kFrags.length !== nodes.length) {\n      throw new Error(`kFrags.length (${kFrags.length}) !== nodes.length (${nodes.length})`)\n    }\n    const storagePromises = []\n    const normalizedTokenAddress = tokenAddress.toLowerCase()\n    for (let i = 0; i < nodes.length; i++) {\n      const peerId = nodes[i]\n      console.debug(`storing kFrag in node ${i + 1} of ${nodes.length}`)\n      // encrypt kfrag with sgx key\n      const serverPubKey = naclUtil.encodeBase64(this.serverPubKeys[peerId])\n      const encryptedKFrag = JSON.stringify(encryptWithPubKey(serverPubKey, kFrags[i], 'x25519-xsalsa20-poly1305'))\n      storagePromises.push(\n        this.storeDataWithNode({\n          peerId,\n          tokenAddress: normalizedTokenAddress,\n          tokenId,\n          fragmentNumber: i,\n          val: encryptedKFrag,\n          authSig,\n          chain,\n          merkleProof\n        })\n      )\n    }\n    const resps = await Promise.all(storagePromises)\n    if (resps.some(k => k === 'AUTH_FAILURE')) {\n      if (this.config.alertWhenUnauthorized) {\n        alert('You are not authorized to publish to this LIT')\n      }\n      document.dispatchEvent(new Event('lit-authFailure'))\n      return { success: false }\n    }\n    console.log('all stored')\n    return { success: true }\n  }\n\n  async getEncryptionKeyFragments ({ tokenAddress, tokenId, authSig, chain, merkleProof }) {\n    // find providers\n    const normalizedTokenAddress = tokenAddress.toLowerCase()\n    const keyId = kFragKey({ tokenAddress, tokenId, chain })\n    const cid = new CID(keyId)\n    const providers = await all(this.libp2p.contentRouting.findProviders(cid, { timeout: 3000 }))\n    console.log(`Found ${providers.length} providers`)\n    const kFragPromises = []\n    for (let i = 0; i < providers.length; i++) {\n      const peerId = providers[i].id.toB58String()\n      console.debug(`Getting ${keyId} from ${peerId}`)\n      kFragPromises.push(this.getDataFromNode({\n        peerId,\n        tokenAddress: normalizedTokenAddress,\n        tokenId,\n        authSig,\n        keyId,\n        chain,\n        merkleProof\n      }))\n    }\n    const kFrags = await Promise.all(kFragPromises)\n    return kFrags\n  }\n\n  async storeDataWithNode ({ peerId, tokenAddress, tokenId, fragmentNumber, val, authSig, chain, merkleProof }) {\n    console.debug(`storing data with node ${peerId} with tokenAddress ${tokenAddress} and tokenId ${tokenId}`)\n    const data = Request.encode({\n      type: Request.Type.STORE_KEY_FRAGMENT,\n      storeKeyFragment: {\n        fragmentValue: uint8arrayFromString(val),\n        fragmentNumber: uint8arrayFromString(fragmentNumber)\n      },\n      authSig: uint8arrayFromString(JSON.stringify(authSig)),\n      tokenParams: {\n        tokenAddress: uint8arrayFromString(tokenAddress),\n        tokenId: uint8arrayFromString(tokenId.toString()),\n        chain: uint8arrayFromString(chain)\n      },\n      merkleProof: uint8arrayFromString(JSON.stringify(merkleProof))\n    })\n    return await this.sendCommandToPeer({ peerId, data })\n  }\n\n  async getDataFromNode ({ peerId, tokenAddress, tokenId, keyId, authSig, chain, merkleProof }) {\n    console.debug(`getDataFromNode ${peerId} with keyId ${keyId}`)\n    const commsKeypair = JSON.parse(localStorage.getItem('lit-comms-keypair'))\n    const data = Request.encode({\n      type: Request.Type.GET_KEY_FRAGMENT,\n      getKeyFragment: {\n        keyId: uint8arrayFromString(keyId)\n      },\n      authSig: uint8arrayFromString(JSON.stringify(authSig)),\n      tokenParams: {\n        tokenAddress: uint8arrayFromString(tokenAddress),\n        tokenId: uint8arrayFromString(tokenId.toString()),\n        chain: uint8arrayFromString(chain)\n      },\n      clientPubKey: naclUtil.decodeBase64(commsKeypair.publicKey),\n      merkleProof: uint8arrayFromString(JSON.stringify(merkleProof))\n    })\n    return await this.sendCommandToPeer({ peerId, data })\n  }\n\n  async handshakeWithSgx ({ peerId }) {\n    console.debug(`handshakeWithSgx ${peerId}`)\n    const data = Request.encode({\n      type: Request.Type.HANDSHAKE\n      // TODO clientPubKey:\n    })\n    return await this.sendCommandToPeer({ peerId, data })\n  }\n\n  async sendCommandToPeer ({ peerId, data }) {\n    const connection = this.libp2p.connectionManager.get(PeerId.createFromB58String(peerId))\n    const { stream } = await connection.newStream(['/lit/1.0.0'])\n    console.debug(`sendCommandToPeer ${peerId}`)\n    let retVal = null\n    await pipe(\n      [data],\n      stream,\n      async (source) => {\n        console.debug('in sendCommandToPeer callback')\n        // seems like for await generators are broken in chrome for now, so pulling out the data manually.\n        const { value, done } = await source.next()\n        // console.debug('got value from source.next()', value)\n        const resp = Response.decode(value.slice())\n        if (resp.type === Response.Type.HANDSHAKE_RESPONSE) {\n          // save pubkey\n          this.serverPubKeys[peerId] = resp.serverPubKey\n          console.log('handshake success for ' + peerId + ' - got server pub key ' + naclUtil.encodeBase64(resp.serverPubKey))\n          retVal = true\n        } else if (resp.type === Response.Type.STORE_KEY_FRAGMENT_RESPONSE) {\n          if (resp.storeKeyFragmentResponse.result === StoreKeyFragmentResponse.Result.SUCCESS) {\n            console.log('success storing key fragment')\n            retVal = true\n          } else if (resp.storeKeyFragmentResponse.result === StoreKeyFragmentResponse.Result.AUTH_FAILURE) {\n            console.log('auth failure.  user doesnt own token')\n            retVal = 'AUTH_FAILURE'\n          } else {\n            console.log('error storing key fragment: ')\n            console.log(uint8arrayToString(resp.storeKeyFragmentResponse.errorMessage))\n            retVal = false\n          }\n        } else if (resp.type === Response.Type.GET_KEY_FRAGMENT_RESPONSE) {\n          if (resp.getKeyFragmentResponse.result === GetKeyFragmentResponse.Result.SUCCESS) {\n            console.log('success getting key fragment')\n            retVal = uint8arrayToString(resp.getKeyFragmentResponse.fragmentValue)\n          } else if (resp.getKeyFragmentResponse.result === GetKeyFragmentResponse.Result.NOT_FOUND) {\n            console.log('key fragment not found')\n            retVal = false\n          } else if (resp.getKeyFragmentResponse.result === GetKeyFragmentResponse.Result.AUTH_FAILURE) {\n            console.log('auth failure.  user doesnt own token')\n            retVal = 'AUTH_FAILURE'\n          } else {\n            console.log('unknown error getting key fragment')\n            retVal = false\n          }\n        } else {\n          console.log('unknown response type')\n        }\n      }\n    )\n    return retVal\n  }\n\n  async connect () {\n    // Create our libp2p node\n    this.libp2p = await Libp2p.create({\n      modules: {\n        transport: [Websockets, WebRTCDirect],\n        connEncryption: [NOISE],\n        streamMuxer: [Mplex],\n        dht: KadDHT,\n        peerDiscovery: [Bootstrap]\n      },\n      config: {\n        dht: {\n          enabled: true\n        },\n        peerDiscovery: {\n          [Bootstrap.tag]: {\n            enabled: true,\n            list: this.config.bootstrapUrls\n          }\n        }\n      }\n    })\n\n    // Listen for new peers\n    this.libp2p.on('peer:discovery', (peerId) => {\n      console.debug(`Found peer ${peerId.toB58String()}`)\n    })\n\n    // Listen for new connections to peers\n    this.libp2p.connectionManager.on('peer:connect', async (connection) => {\n      const peerId = connection.remotePeer.toB58String()\n      console.debug(`Connected to ${peerId}`)\n      if (this.connectedNodes.has(peerId)) {\n        return\n      }\n      this.connectedNodes.add(peerId)\n      // handshake.  wait a second for the connection to settle.\n      setTimeout(async () => {\n        await this.handshakeWithSgx({ peerId })\n      }, 1000)\n    })\n\n    // Listen for peers disconnecting\n    this.libp2p.connectionManager.on('peer:disconnect', (connection) => {\n      const peerId = connection.remotePeer.toB58String()\n      console.debug(`Disconnected from ${peerId}`)\n      this.connectedNodes.delete(peerId)\n    })\n\n    await this.libp2p.start()\n    console.debug(`libp2p id is ${this.libp2p.peerId.toB58String()}`)\n    this.libp2p.multiaddrs.forEach((ma) => console.debug(`${ma.toString()}/p2p/${this.libp2p.peerId.toB58String()}`))\n\n    const interval = window.setInterval(() => {\n      if (Array.from(this.connectedNodes).length >= this.config.minNodeCount) {\n        clearInterval(interval)\n        this.ready = true\n        console.debug('lit is ready')\n        document.dispatchEvent(new Event('lit-ready'))\n      }\n    }, 1000)\n\n    // Export libp2p to the window so you can play with the API\n    window.libp2p = this.libp2p\n    window.PeerId = PeerId\n    // const hashed = multihashing(Buffer.from('1'), 'sha2-256')\n    // window.cid = new CID(hashed)\n\n    // const node1PeerId = PeerId.createFromB58String('QmXQtURimWjx8ihhWp1jjMv3rnv8xzq1qwY6KSzMr8dSGL')\n    // const ma = multiaddr('/ip4/127.0.0.1/tcp/9092/ws/p2p')\n    // libp2p.peerStore.addressBook.set(node1PeerId, [ma])\n  }\n}\n","import 'regenerator-runtime/runtime'\n\nimport {\n  zipAndEncryptString,\n  zipAndEncryptFiles,\n  encryptZip,\n  decryptZip,\n  createHtmlLIT,\n  toggleLock\n} from './utils/lit'\n\nimport {\n  connectWeb3,\n  mintLIT,\n  checkAndSignAuthMessage,\n  getMerkleProof,\n  findLITs,\n  sendLIT\n} from './utils/eth'\n\nimport {\n  decryptWithPrivKey,\n  encryptWithPubKey\n} from './utils/crypto'\n\nimport { fileToDataUrl } from './utils/browser'\n\nimport { LIT_CHAINS, protobufs } from './lib/constants'\nimport { kFragKey } from './lib/utils'\n\nimport LitNodeClient from './utils/litNodeClient'\n\nimport { litJsSdkLoadedInALIT } from './utils/init'\n\nimport {\n  listenForChildFrameMessages,\n  listenForFrameParentMessages,\n  inIframe\n} from './utils/frameComms'\n\nif (inIframe()) {\n  listenForFrameParentMessages()\n} else {\n  listenForChildFrameMessages()\n}\n\nconst functions = {\n  zipAndEncryptString,\n  zipAndEncryptFiles,\n  encryptZip,\n  decryptZip,\n  connectWeb3,\n  checkAndSignAuthMessage,\n  createHtmlLIT,\n  mintLIT,\n  toggleLock,\n  LIT_CHAINS,\n  LitNodeClient,\n  protobufs,\n  kFragKey,\n  encryptWithPubKey,\n  decryptWithPrivKey,\n  fileToDataUrl,\n  getMerkleProof,\n  findLITs,\n  sendLIT,\n  litJsSdkLoadedInALIT\n}\n\nexport default functions\n","import { sendMessageToFrameParent } from './frameComms'\nimport LitNodeClient from './litNodeClient'\n\nexport const litJsSdkLoadedInALIT = () => {\n  sendMessageToFrameParent({ command: 'LIT_SYN' }, '*')\n  setTimeout(function () {\n    if (!useLitPostMessageProxy) {\n      console.log('inside lit - no parent frame lit node connection.  connecting ourselves.')\n      // we're on our own with no parent frame.  initiate our own connection to lit nodes\n      const litNodeClient = new LitNodeClient()\n      litNodeClient.connect()\n      window.litNodeClient = litNodeClient\n    } else {\n      console.log('inside lit - parent frame is connected to lit nodes.  using that.')\n    }\n  }, 1000)\n}\n"],"names":["runtime","exports","undefined","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","GenStateSuspendedStart","method","arg","GenStateExecuting","Error","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","done","GenStateSuspendedYield","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","invoke","resolve","reject","result","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","SYMM_KEY_ALGO_PARAMS","encryptWithPubKey","receiverPublicKey","data","version","pubKeyUInt8Array","ephemeralKeyPair","nacl","box","keyPair","naclUtil","decodeBase64","msgParamsUInt8Array","decodeUTF8","nonce","randomBytes","nonceLength","encryptedMessage","secretKey","encodeBase64","ephemPublicKey","publicKey","ciphertext","decryptWithPrivKey","encryptedData","receiverPrivateKey","output","recieverEncryptionPrivateKey","decryptedMessage","open","encodeUTF8","protobufs","protons","LIT_CHAINS","polygon","contractAddress","chainId","symbol","decimals","rpcUrls","blockExplorerUrls","balanceStorageSlot","ethereum","kovan","body","recover","e","signAndSaveAuthMessage","now","Date","toISOString","AUTH_SIGNATURE_BODY","replace","connectWeb3","web3","account","console","log","request","params","signature","address","verifyMessage","toLowerCase","msg","alert","signMessage","signedResult","localStorage","setItem","JSON","stringify","sig","derivedVia","signedMessage","commsKeyPair","checkAndSignAuthMessage","chain","authSig","parse","getItem","selectedChain","selectedChainId","debug","chainName","nativeCurrency","res","errorCode","getMerkleProof","tokenAddress","tokenId","storageAddress","mappingAt","parseInt","rpcBlock","number","rpcProof","header","accountProof","storageProof","proof","blockHash","hash","window","message","detectEthereumProvider","provider","accounts","sendMessageToFrameParent","parent","postMessage","fileToDataUrl","file","reader","FileReader","onloadend","readAsDataURL","pact","s","o","_settle","bind","v","observer","_Pact","onFulfilled","onRejected","callback","_this","encryptZip","zip","generateAsync","zipBlob","arrayBuffer","zipBlobArrayBuffer","crypto","subtle","generateKey","generateSymmetricKey","symmKey","iv","getRandomValues","Uint8Array","encrypt","encryptedZipData","Blob","encryptWithSymmetricKey","encryptedZipBlob","exportKey","exportedSymmKey","symmetricKey","encryptedZip","decryptZip","jwkSymmKey","importKey","importSymmetricKey","importedSymmKey","encryptedBlob","recoveredIv","encryptedZipArrayBuffer","decrypt","decryptWithSymmetricKey","decryptedZipArrayBuffer","JSZip","loadAsync","unzipped","files","PACKAGE_CACHE","kFragKey","normalizedTokenAddress","normalizedTokenId","padStart","hashed","multihashing","Buffer","from","CID","Request","Response","StoreKeyFragmentResponse","GetKeyFragmentResponse","LitNodeClient","config","alertWhenUnauthorized","minNodeCount","bootstrapUrls","libp2p","connectedNodes","Set","serverPubKeys","ready","getEncryptionKey","merkleProof","_this2","getEncryptionKeyFragments","encryptedKFrags","some","k","document","dispatchEvent","Event","commsKeypair","kFrags","decrypted","secret","secrets","combine","uint8arrayToString","uint8arrayFromString","saveEncryptionKey","nodes","Array","_this4","numShares","threshold","Math","floor","share","storagePromises","peerId","serverPubKey","encryptedKFrag","storeDataWithNode","fragmentNumber","val","all","resps","success","keyId","cid","_this6","contentRouting","findProviders","timeout","providers","kFragPromises","id","toB58String","getDataFromNode","encode","Type","STORE_KEY_FRAGMENT","storeKeyFragment","fragmentValue","tokenParams","sendCommandToPeer","GET_KEY_FRAGMENT","getKeyFragment","clientPubKey","handshakeWithSgx","HANDSHAKE","connection","_this14","connectionManager","get","PeerId","createFromB58String","newStream","stream","retVal","pipe","source","resp","decode","HANDSHAKE_RESPONSE","STORE_KEY_FRAGMENT_RESPONSE","storeKeyFragmentResponse","Result","SUCCESS","AUTH_FAILURE","errorMessage","GET_KEY_FRAGMENT_RESPONSE","getKeyFragmentResponse","NOT_FOUND","connect","Libp2p","modules","transport","Websockets","WebRTCDirect","connEncryption","NOISE","streamMuxer","Mplex","dht","KadDHT","peerDiscovery","Bootstrap","enabled","tag","list","_this16","on","remotePeer","has","add","setTimeout","start","multiaddrs","ma","interval","setInterval","clearInterval","top","inIframe","origin","addEventListener","event","childFrameThatSentMessageIndex","frames","command","response","target","litNodeClient","encryptionKey","respondingToCommand","listenForChildFrameMessages","messageIsFromFrameParent","useLitPostMessageProxy","LitJsSdk","toggleLock","encryptionKeyFromParentFrame","listenForFrameParentMessages","functions","zipAndEncryptString","string","zipAndEncryptFiles","folder","createHtmlLIT","array","title","htmlBody","css","encryptedZipDataUrl","npmPackages","scriptTags","packageName","fetch","ok","statusText","blob","dataUrl","getNpmPackage","scriptDataUrl","_cycle","thenable","mintLIT","quantity","contract","Contract","LIT","Web3Provider","getSigner","mint","tx","wait","txReceipt","events","args","toNumber","txHash","transactionHash","mintingAddress","code","mediaGridHolder","getElementById","lockedHeader","locked","publicContent","innerHTML","_fetch","decryptedFiles","mediaGridHtmlBody","innerText","unlockLitWithKey","_exit","findLITs","chainHexId","chainHexIdToChainName","tokenIds","maxTokenId","balanceOfBatch","balances","map","b","filter","sendLIT","tokenMetadata","to","safeTransferFrom","litJsSdkLoadedInALIT"],"mappings":"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"}