{"version":3,"file":"index.modern.js","sources":["../src/utils/crypto.js","../src/utils/lit.js","../src/utils/browser.js","../src/utils/firebase.js","../src/lib/constants.js","../src/utils/eth.js","../src/lib/utils.js","../src/utils/lit-node-client.js","../src/index.js","../src/utils/cloudFunctions.js"],"sourcesContent":["\nimport nacl from 'tweetnacl'\nimport naclUtil from 'tweetnacl-util'\n\nconst SYMM_KEY_ALGO_PARAMS = {\n  name: 'AES-CBC',\n  length: 256\n}\n\nexport function compareArrayBuffers (buf1, buf2) {\n  if (buf1.byteLength !== buf2.byteLength) return false\n  const dv1 = new Uint8Array(buf1)\n  const dv2 = new Uint8Array(buf2)\n  for (let i = 0; i !== buf1.byteLength; i++) {\n    if (dv1[i] !== dv2[i]) return false\n  }\n  return true\n}\n\nexport async function importSymmetricKey (jwkSymmKey) {\n  const importedSymmKey = await crypto.subtle.importKey(\n    'jwk',\n    JSON.parse(jwkSymmKey),\n    SYMM_KEY_ALGO_PARAMS,\n    true,\n    ['encrypt', 'decrypt']\n  )\n  return importedSymmKey\n}\nexport async function generateSymmetricKey () {\n  const symmKey = await crypto.subtle.generateKey(\n    SYMM_KEY_ALGO_PARAMS,\n    true,\n    ['encrypt', 'decrypt']\n  )\n  return symmKey\n}\n\nexport async function decryptWithSymmetricKey (\n  encryptedBlob,\n  symmKey\n) {\n  const recoveredIv = await encryptedBlob.slice(0, 16).arrayBuffer()\n  const encryptedZipArrayBuffer = await encryptedBlob.slice(16).arrayBuffer()\n  const decryptedZip = await crypto.subtle.decrypt(\n    {\n      name: 'AES-CBC',\n      iv: recoveredIv\n    },\n    symmKey,\n    encryptedZipArrayBuffer\n  )\n  return decryptedZip\n}\n\n// used this as an example\n// https://github.com/infotechinc/symmetric-encryption-in-browser/blob/master/crypto.js\nexport async function encryptWithSymmetricKey (\n  symmKey,\n  data\n) {\n  // encrypt the zip with symmetric key\n  const iv = window.crypto.getRandomValues(new Uint8Array(16))\n\n  const encryptedZipData = await crypto.subtle.encrypt(\n    {\n      name: 'AES-CBC',\n      iv\n    },\n    symmKey,\n    data\n  )\n  const encryptedZipBlob = new Blob([iv, new Uint8Array(encryptedZipData)], { type: 'application/octet-stream' })\n  return encryptedZipBlob\n}\n\n// borrowed from eth-sig-util from meatmask.\nexport function encryptWithPubkey (\n  receiverPublicKey,\n  data,\n  version\n) {\n  switch (version) {\n    case 'x25519-xsalsa20-poly1305': {\n      // generate ephemeral keypair\n      const ephemeralKeyPair = nacl.box.keyPair()\n\n      // assemble encryption parameters - from string to UInt8\n      let pubKeyUInt8Array\n      try {\n        pubKeyUInt8Array = naclUtil.decodeBase64(receiverPublicKey)\n      } catch (err) {\n        throw new Error('Bad public key')\n      }\n\n      const msgParamsUInt8Array = naclUtil.decodeUTF8(data)\n      const nonce = nacl.randomBytes(nacl.box.nonceLength)\n\n      // encrypt\n      const encryptedMessage = nacl.box(\n        msgParamsUInt8Array,\n        nonce,\n        pubKeyUInt8Array,\n        ephemeralKeyPair.secretKey\n      )\n\n      // handle encrypted data\n      const output = {\n        version: 'x25519-xsalsa20-poly1305',\n        nonce: naclUtil.encodeBase64(nonce),\n        ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),\n        ciphertext: naclUtil.encodeBase64(encryptedMessage)\n      }\n      // return encrypted msg data\n      return output\n    }\n\n    default:\n      throw new Error('Encryption type/version not supported')\n  }\n}\n\n// borrowed from eth-sig-util from meatmask.\nexport function decryptWithPrivkey (\n  encryptedData,\n  receiverPrivateKey\n) {\n  switch (encryptedData.version) {\n    case 'x25519-xsalsa20-poly1305': {\n      const recieverEncryptionPrivateKey = naclUtil.decodeBase64(receiverPrivateKey)\n\n      // assemble decryption parameters\n      const nonce = naclUtil.decodeBase64(encryptedData.nonce)\n      const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext)\n      const ephemPublicKey = naclUtil.decodeBase64(\n        encryptedData.ephemPublicKey\n      )\n\n      // decrypt\n      const decryptedMessage = nacl.box.open(\n        ciphertext,\n        nonce,\n        ephemPublicKey,\n        recieverEncryptionPrivateKey\n      )\n\n      // return decrypted msg data\n      let output\n      try {\n        output = naclUtil.encodeUTF8(decryptedMessage)\n      } catch (err) {\n        throw new Error('Decryption failed.')\n      }\n\n      if (output) {\n        return output\n      }\n      throw new Error('Decryption failed.')\n    }\n\n    default:\n      throw new Error('Encryption type/version not supported.')\n  }\n}\n","import JSZip from 'jszip'\n\nimport {\n  importSymmetricKey,\n  generateSymmetricKey,\n  encryptWithSymmetricKey,\n  decryptWithSymmetricKey,\n  compareArrayBuffers\n} from './crypto'\n\n// import {\n//   checkAndDeriveKeypair,\n//   decryptWithWeb3PrivateKey\n// } from './eth'\n\nimport { fileToDataUrl } from './browser'\n\nconst PACKAGE_CACHE = {}\n\nexport async function zipAndEncryptString (string) {\n  const zip = new JSZip()\n  zip.file('string.txt', string)\n  return encryptZip(zip)\n}\n\nexport async function zipAndEncryptFiles (files) {\n  // let's zip em\n  const zip = new JSZip()\n  for (let i = 0; i < files.length; i++) {\n    zip.folder('encryptedAssets').file(files[i].name, files[i])\n  }\n  return encryptZip(zip)\n}\n\nexport async function decryptZip (encryptedZipBlob, symmKey) {\n  // const keypair = await checkAndDeriveKeypair()\n\n  // console.log('Got keypair out of localstorage: ' + keypair)\n  // const privkey = keypair.secretKey\n\n  // let decryptedSymmKey = await decryptWithWeb3PrivateKey(symmKey)\n  // if (!decryptedSymmKey) {\n  //   // fallback to trying the private derived via signature\n  //   console.log('probably not metamask')\n  //   decryptedSymmKey = decryptWithPrivkey(symmKey, privkey)\n  // }\n  // console.log('decrypted', decryptedSymmKey)\n\n  // import the decrypted symm key\n  const importedSymmKey = await importSymmetricKey(symmKey)\n\n  const decryptedZipArrayBuffer = await decryptWithSymmetricKey(\n    encryptedZipBlob,\n    importedSymmKey\n  )\n\n  // unpack the zip\n  const zip = new JSZip()\n  const unzipped = await zip.loadAsync(decryptedZipArrayBuffer)\n\n  // load the files into data urls with the metadata attached\n  // const files = await Promise.all(unzipped.files.map(async f => {\n  //   // const dataUrl = await fileToDataUrl(f)\n  //   return {\n  //     type: f.type,\n  //     name: f.name,\n  //     file: f\n  //   }\n  // }))\n\n  return unzipped.files\n}\n\nexport async function encryptZip (zip) {\n  const zipBlob = await zip.generateAsync({ type: 'blob' })\n  const zipBlobArrayBuffer = await zipBlob.arrayBuffer()\n  console.log('blob', zipBlob)\n\n  const symmKey = await generateSymmetricKey()\n  const encryptedZipBlob = await encryptWithSymmetricKey(\n    symmKey,\n    zipBlobArrayBuffer\n  )\n\n  // to download the encrypted zip file for testing, uncomment this\n  // saveAs(encryptedZipBlob, 'encrypted.bin')\n\n  const exportedSymmKey = await crypto.subtle.exportKey('jwk', symmKey)\n  console.log('exportedSymmKey', exportedSymmKey)\n\n  // encrypt the symmetric key with the\n  // public key derived from the eth wallet\n  // const keypair = await checkAndDeriveKeypair()\n  // const pubkey = keypair.publicKey\n  // const privkey = keypair.secretKey\n\n  // encrypt symm key\n  // const encryptedSymmKeyData = encryptWithPubkey(pubkey, JSON.stringify(exportedSymmKey), 'x25519-xsalsa20-poly1305')\n  // const packed = JSON.stringify(encryptedSymmKeyData)\n\n  //   console.log('packed symmetric key ', packed)\n  //   const unpacked = JSON.parse(packed)\n  //   // test decrypt\n  //   const decryptedSymmKey = decryptWithPrivkey(unpacked, privkey)\n  //   console.log('decrypted', decryptedSymmKey)\n  //\n  //   // import the decrypted symm key\n  //   const importedSymmKey = await importSymmetricKey(decryptedSymmKey)\n  //\n  //   const decryptedZipArrayBuffer = await decryptWithSymmetricKey(\n  //     encryptedZipBlob,\n  //     importedSymmKey\n  //   )\n  //\n  //   // compare zip before and after as a sanity check\n  //   const isEqual = compareArrayBuffers(\n  //     zipBlobArrayBuffer,\n  //     decryptedZipArrayBuffer\n  //   )\n  //   console.log('Zip before and after decryption are equal: ', isEqual)\n  //   if (!isEqual) {\n  //     throw new Error('Decrypted zip does not match original zip.  Something is wrong.')\n  //   }\n\n  // to download the zip, for testing, uncomment this\n  //   const decryptedBlob = new Blob(\n  //     [decryptedZipArrayBuffer],\n  //     { type: 'application/zip' }\n  //   )\n  //   console.log('decrypted blob', decryptedBlob)\n  //\n  //   saveAs(decryptedBlob, 'decrypted.zip')\n  // console.log('saved')\n\n  return {\n    symmetricKey: exportedSymmKey,\n    encryptedZip: encryptedZipBlob\n  }\n}\n\nasync function getNpmPackage (packageName) {\n  // console.log('getting npm package: ' + packageName)\n  if (PACKAGE_CACHE[packageName]) {\n    // console.log('found in cache')\n    return PACKAGE_CACHE[packageName]\n  }\n\n  const resp = await fetch('https://unpkg.com/' + packageName)\n  if (!resp.ok) {\n    console.log('error with response: ', resp)\n    throw Error(resp.statusText)\n  }\n  const blob = await resp.blob()\n  // console.log('got blob', blob)\n  const dataUrl = await fileToDataUrl(blob)\n  // console.log('got dataUrl', dataUrl)\n  PACKAGE_CACHE[packageName] = dataUrl\n  return dataUrl\n}\n\nexport async function createHtmlLIT ({\n  title,\n  htmlBody,\n  css,\n  encryptedSymmetricKey,\n  encryptedZipDataUrl,\n  npmPackages = []\n}) {\n  npmPackages.push('lit-js-sdk')\n  // console.log('createHtmlLIT with npmPackages', npmPackages)\n  let scriptTags = ''\n  for (let i = 0; i < npmPackages.length; i++) {\n    const scriptDataUrl = await getNpmPackage(npmPackages[i])\n    const tag = `<script src=\"${scriptDataUrl}\"></script>\\n`\n    scriptTags += tag\n  }\n\n  // console.log('scriptTags: ', scriptTags)\n\n  return `\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>${title}</title>\n    <style id=\"jss-server-side\">${css}</style>\n    ${scriptTags}\n    <script>\n      var encryptedSymmetricKey = ${encryptedSymmetricKey}\n      var encryptedZipDataUrl = \"${encryptedZipDataUrl}\"\n      var locked = true\n    </script>\n  </head>\n  <body>\n    <div id=\"root\">${htmlBody}</div>\n    <script>\n      const unlockButton = document.getElementById('unlockButton')\n      unlockButton.onclick = function() {\n        LitJsSdk.default.toggleLock()\n      }\n    </script>\n  </body>\n</html>\n  `\n}\n\nexport async function toggleLock () {\n  const mediaGridHolder = document.getElementById('mediaGridHolder')\n  const lockedHeader = document.getElementById('lockedHeader')\n\n  if (window.locked) {\n    // save public content before decryption, so we can toggle back to the\n    // locked state in the future\n    window.publicContent = mediaGridHolder.innerHTML\n    // convert data url to blob\n    const encryptedZipBlob = await (await fetch(window.encryptedZipDataUrl)).blob()\n    const decryptedFiles = await decryptZip(encryptedZipBlob, JSON.stringify(window.encryptedSymmetricKey))\n    const mediaGridHtmlBody = await decryptedFiles['string.txt'].async('text')\n    mediaGridHolder.innerHTML = mediaGridHtmlBody\n    lockedHeader.innerText = 'UNLOCKED'\n    window.locked = false\n  } else {\n    mediaGridHolder.innerHTML = window.publicContent\n    lockedHeader.innerText = 'LOCKED'\n    window.locked = true\n  }\n}\n","export function fileToDataUrl (file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader()\n    reader.onloadend = () => {\n      resolve(reader.result)\n    }\n    reader.readAsDataURL(file)\n  })\n}\n","import firebase from 'firebase/app'\nimport 'firebase/functions'\n\nconst firebaseConfig = {\n  apiKey: 'AIzaSyDa3JnwzrjfY5DcPz4GtywdUUUY3zqWo0w',\n  authDomain: 'mintlit.firebaseapp.com',\n  projectId: 'mintlit',\n  storageBucket: 'mintlit.appspot.com',\n  messagingSenderId: '1044454922569',\n  appId: '1:1044454922569:web:a3cf1d5637f18413f66298',\n  measurementId: 'G-NC19HWVQPT'\n}\n\n// Initialize Firebase\nfirebase.initializeApp(firebaseConfig)\n\nexport default firebase\n","const protons = require('protons')\n\nexport const protobufs = protons(`\nmessage Request {\n  enum Type {\n    GET_KEY_FRAGMENT = 0;\n    STORE_KEY_FRAGMENT = 1;\n  }\n  required Type type = 1;\n  optional GetKeyFragment getKeyFragment = 2;\n  optional StoreKeyFragment storeKeyFragment = 3;\n  optional bytes authSig = 4;\n  optional TokenParams tokenParams = 5;\n}\nmessage Response {\n  enum Type {\n    GET_KEY_FRAGMENT_RESPONSE = 0;\n    STORE_KEY_FRAGMENT_RESPONSE = 1;\n  }\n  required Type type = 1;\n  optional GetKeyFragmentResponse getKeyFragmentResponse = 2;\n  optional StoreKeyFragmentResponse storeKeyFragmentResponse = 3;\n}\nmessage GetKeyFragment {\n  required bytes keyId = 4;\n}\nmessage GetKeyFragmentResponse {\n  enum Result {\n    SUCCESS = 0;\n    NOT_FOUND = 1;\n    ERROR = 2;\n  }\n  required Result result = 1;\n  optional bytes keyId = 2;\n  optional bytes fragmentValue = 3;\n}\nmessage StoreKeyFragment {\n  required bytes fragmentValue = 4;\n}\nmessage StoreKeyFragmentResponse {\n  enum Result {\n    SUCCESS = 0;\n    AUTH_FAILURE = 1;\n    ERROR = 2;\n  }\n  required Result result = 1;\n  optional bytes errorMessage = 2;\n}\nmessage TokenParams {\n  required bytes tokenAddress = 1;\n  required bytes tokenId = 2;\n  required bytes chain = 3;\n}\n`)\n\nexport const LIT_CHAINS = {\n  polygon: {\n    contractAddress: '0xb9A323711528D0c5a70df790929f4739f1cDd7fD',\n    chainId: 137\n  },\n  ethereum: {\n    contractAddress: '0x55485885e82E25446DEC314Ccb810Bda06B9e01B',\n    chainId: 1\n  }\n}\n","import Web3 from 'web3'\n\nimport detectEthereumProvider from '@metamask/detect-provider'\n\nimport naclUtil from 'tweetnacl-util'\nimport nacl from 'tweetnacl'\nimport { getPublicKey, savePublicKey } from './cloudFunctions'\n\nimport LIT from '../abis/LIT.json'\nimport { LIT_CHAINS } from '../lib/constants'\n\nconst AUTH_SIGNATURE_BODY = 'I am creating an account to use LITs at {{timestamp}}'\n\n// export async function checkAndDeriveKeypair () {\n//   let keypair = localStorage.getItem('lit-keypair')\n//   if (!keypair) {\n//     await deriveEncryptionKeys()\n//     keypair = localStorage.getItem('lit-keypair')\n//   }\n//   keypair = JSON.parse(keypair)\n//   const { web3, account } = await connectWeb3()\n//   // make sure we are on the right account\n//   if (account !== keypair.address) {\n//     await deriveEncryptionKeys()\n//     keypair = localStorage.getItem('lit-keypair')\n//     keypair = JSON.parse(keypair)\n//   }\n//   return keypair\n// }\n\nexport async function connectWeb3 () {\n  if (typeof window.ethereum === 'undefined') {\n    throw new Error({ errorCode: 'no_wallet', message: 'No web3 wallet was found' })\n  }\n\n  const provider = await detectEthereumProvider()\n\n  // trigger metamask popup\n  const accounts = await provider.request({ method: 'eth_requestAccounts' })\n  const account = accounts[0].toLowerCase()\n\n  const web3 = new Web3(provider)\n  return { web3, account }\n}\n\nexport async function checkAndSignAuthMessage () {\n  let authSig = localStorage.getItem('lit-auth-signature')\n  if (!authSig) {\n    await signAndSaveAuthMessage()\n    authSig = localStorage.getItem('lit-auth-signature')\n  }\n  authSig = JSON.parse(authSig)\n  const { web3, account } = await connectWeb3()\n  // make sure we are on the right account\n  if (account !== authSig.address) {\n    await signAndSaveAuthMessage()\n    authSig = localStorage.getItem('lit-auth-signature')\n    authSig = JSON.parse(authSig)\n  }\n  return authSig\n}\n\nexport async function signAndSaveAuthMessage () {\n  const now = (new Date()).toISOString()\n  const body = AUTH_SIGNATURE_BODY.replace('{{timestamp}}', now)\n  const signedResult = await signMessage({ body })\n  localStorage.setItem('lit-auth-signature', JSON.stringify({\n    sig: signedResult.signature,\n    derivedVia: 'web3.eth.personal.sign',\n    signedMessage: body,\n    address: signedResult.address\n  }))\n}\n\nexport async function signMessage ({ body }) {\n  const { web3, account } = await connectWeb3()\n\n  console.log('signing with ', account)\n  const signature = await web3.eth.personal.sign(body, account)\n  const address = web3.eth.accounts.recover(body, signature).toLowerCase()\n\n  console.log('Signature: ', signature)\n  console.log('recovered address: ', address)\n\n  if (address !== account) {\n    const msg = `ruh roh, the user signed with a different address (${address}) then they\\'re using with web3 (${account}).  this will lead to confusion.`\n    console.error(msg)\n    alert('something seems to be wrong with your wallets message signing.  maybe restart your browser or your wallet.  your recovered sig address does not match your web3 account address')\n    throw new Error(msg)\n  }\n\n  return { signature, address }\n}\n\n// export async function decryptWithWeb3PrivateKey (encryptedData) {\n//   const { web3, account } = await connectWeb3()\n//   try {\n//     const decryptedMessage = ethereum\n//       .request({\n//         method: 'eth_decrypt',\n//         params: [encryptedData, account]\n//       })\n//     return decryptedMessage\n//   } catch (error) {\n//     console.log(error)\n//     return false\n//   }\n// }\n//\n// async function deriveKeysViaSignature () {\n//   const { signature, address } = await signMessage({ body: KEY_DERIVATION_SIGNATURE_BODY })\n//   console.log('Signed message: ' + signature)\n//\n//   // derive keypair\n//   const data = Buffer.from(signature.substring(2), 'hex')\n//   const hash = await crypto.subtle.digest('SHA-256', data)\n//   const uint8Hash = new Uint8Array(hash)\n//   const { publicKey, secretKey } = nacl.box.keyPair.fromSecretKey(uint8Hash)\n//   return {\n//     publicKey: naclUtil.encodeBase64(publicKey),\n//     secretKey: naclUtil.encodeBase64(secretKey)\n//   }\n// }\n//\n// // this only works on metamask :(\n// async function deriveKeysViaPrivateKey () {\n//   try {\n//     const { web3, account } = await connectWeb3()\n//     /* global ethereum */\n//     /* eslint no-undef: \"error\" */\n//     const publicKey = await ethereum\n//       .request({\n//         method: 'eth_getEncryptionPublicKey',\n//         params: [account] // you must have access to the specified account\n//       })\n//     return { publicKey }\n//   } catch (error) {\n//     console.log(error)\n//     if (error.code === 4001) {\n//       // EIP-1193 userRejectedRequest error\n//       console.log(\"We can't encrypt anything without the key.\")\n//       error('You must accept the metamask request to derive your public encryption key')\n//     } else {\n//       console.error(error)\n//     }\n//     return { error }\n//   }\n// }\n//\n// export async function deriveEncryptionKeys () {\n//   let keypair = {}\n//   // key derivation via metamask is more desirable because then even this SDK can't see the secret key :-D\n//   const { error, publicKey } = await deriveKeysViaPrivateKey()\n//   if (!error) {\n//     keypair = {\n//       publicKey,\n//       derivedVia: 'eth_getEncryptionPublicKey'\n//     }\n//   } else {\n//     const { publicKey, secretKey } = await deriveKeysViaSignature()\n//     keypair = {\n//       publicKey,\n//       secretKey,\n//       derivedVia: 'web3.eth.personal.sign',\n//       signedMessage: KEY_DERIVATION_SIGNATURE_BODY\n//     }\n//   }\n//\n//   const { web3, account } = await connectWeb3()\n//   keypair.address = account\n//\n//   console.log('public key: ' + keypair.publicKey)\n//   const asString = JSON.stringify(keypair)\n//   localStorage.setItem('lit-keypair', asString)\n//\n//   // is it already saved on the server?\n//   const { pubkey, errorCode } = await getPublicKey({\n//     address: account\n//   })\n//   if (errorCode === 'not_found' || pubkey !== keypair.publicKey) {\n//     // add it\n//     const msg = `I am saving my public key so that others can send me LITs.  It is ${pubkey}`\n//     const res = await signMessage({ body: msg })\n//     await savePublicKey({\n//       sig: res.signature,\n//       msg,\n//       pubkey: keypair.publicKey\n//     })\n//   }\n// }\n\nexport async function mintLIT ({ chain, quantity }) {\n  console.log(`minting ${quantity} tokens on ${chain}`)\n  const authSig = await checkAndSignAuthMessage()\n  const { web3, account } = await connectWeb3()\n  const chainId = await web3.eth.getChainId()\n  if (chainId !== LIT_CHAINS[chain].chainId) {\n    return { errorCode: 'wrong_chain' }\n  }\n  const tokenAddress = LIT_CHAINS[chain].contractAddress\n  const contract = new web3.eth.Contract(LIT.abi, tokenAddress)\n  console.log('sending to chain...')\n  try {\n    const txReceipt = await contract.methods.mint(quantity).send({ from: account })\n    console.log('txReceipt: ', txReceipt)\n    const tokenId = txReceipt.events.TransferSingle.returnValues.id\n    return {\n      txHash: txReceipt.transactionHash,\n      tokenId,\n      tokenAddress,\n      mintingAddress: account,\n      authSig\n    }\n  } catch (error) {\n    console.log(error)\n    if (error.code === 4001) {\n      // EIP-1193 userRejectedRequest error\n      console.log('User rejected request')\n      return { errorCode: 'user_rejected_request' }\n    } else {\n      console.error(error)\n    }\n    return { errorCode: 'unknown_error' }\n  }\n}\n","import multihashing from 'multihashing'\nimport CID from 'cids'\n\nexport const kFragKey = ({ tokenAddress, tokenId, chain }) => {\n  const normalizedTokenAddress = tokenAddress.toLowerCase()\n  const normalizedTokenId = tokenId.toString(16).padStart(64, '0') // to hex and padded for consistent length\n  const formattedKey = `${normalizedTokenAddress}|${normalizedTokenId}|${chain}`\n  const hashed = multihashing(Buffer.from(formattedKey), 'sha2-256')\n  const cid = new CID(hashed)\n  return cid.toString()\n}\n","// import 'babel-polyfill'\nimport Libp2p from 'libp2p'\nimport Websockets from 'libp2p-websockets'\nimport WebRTCDirect from 'libp2p-webrtc-direct'\nimport { NOISE } from 'libp2p-noise'\nimport Mplex from 'libp2p-mplex'\nimport KadDHT from 'libp2p-kad-dht'\nimport PeerId from 'peer-id'\nimport { multiaddr } from 'multiaddr'\nimport Bootstrap from 'libp2p-bootstrap'\nimport pipe from 'it-pipe'\nimport lp from 'it-length-prefixed'\nimport multihashing from 'multihashing'\nimport CID from 'cids'\nimport pushable from 'it-pushable'\nimport secrets from 'secrets.js-grempe'\nimport uint8arrayFromString from 'uint8arrays/from-string'\nimport uint8arrayToString from 'uint8arrays/to-string'\nimport { protobufs } from '../lib/constants'\nimport { kFragKey } from '../lib/utils'\nimport all from 'it-all'\n\nconst { Request, Response, StoreKeyFragmentResponse, GetKeyFragmentResponse } = protobufs\n\nexport default class LitNodeClient {\n  constructor (config) {\n    this.libp2p = null\n    this.connectedNodes = new Set()\n  }\n\n  async saveEncryptionKey ({ tokenAddress, tokenId, symmetricKey, authSig, chain }) {\n    const nodes = Array.from(this.connectedNodes)\n    // split up into nodes.length fragments\n    const numShares = nodes.length\n    const threshold = Math.floor(numShares / 2)\n    // convert from base64 to hex\n    const secret = Buffer.from(symmetricKey).toString('hex')\n    console.debug(`splitting up into ${numShares} shares with a threshold of ${threshold}`)\n    const kFrags = secrets.share(secret, numShares, threshold)\n    if (kFrags.length !== nodes.length) {\n      throw new Error(`kFrags.length (${kFrags.length}) !== nodes.length (${nodes.length})`)\n    }\n    const storagePromises = []\n    const normalizedTokenAddress = tokenAddress.toLowerCase()\n    for (let i = 0; i < nodes.length; i++) {\n      console.debug(`storing kFrag in node ${i + 1} of ${nodes.length}`)\n      storagePromises.push(\n        this.storeDataWithNode({\n          peerId: nodes[i],\n          tokenAddress: normalizedTokenAddress,\n          tokenId,\n          val: kFrags[i],\n          authSig,\n          chain\n        })\n      )\n    }\n    await Promise.all(storagePromises)\n    console.log('all stored')\n    return { success: true }\n  }\n\n  async getEncryptionKeyFragments ({ tokenAddress, tokenId, authSig, chain }) {\n    // find providers\n    const normalizedTokenAddress = tokenAddress.toLowerCase()\n    const keyId = kFragKey({ tokenAddress, tokenId, chain })\n    const cid = new CID(keyId)\n    const providers = await all(this.libp2p.contentRouting.findProviders(cid, { timeout: 3000 }))\n    console.log(`Found ${providers.length} providers`)\n    const kFragPromises = []\n    for (let i = 0; i < providers.length; i++) {\n      const peerId = providers[i].id.toB58String()\n      console.debug(`Getting ${keyId} from ${peerId}`)\n      kFragPromises.push(this.getDataFromNode({\n        peerId,\n        tokenAddress: normalizedTokenAddress,\n        tokenId,\n        authSig,\n        keyId,\n        chain\n      }))\n    }\n    const kFrags = await Promise.all(kFragPromises)\n    return kFrags\n  }\n\n  async storeDataWithNode ({ peerId, tokenAddress, tokenId, val, authSig, chain }) {\n    console.debug(`storing data with node ${peerId} with tokenAddress ${tokenAddress} and tokenId ${tokenId}`)\n    const data = Request.encode({\n      type: Request.Type.STORE_KEY_FRAGMENT,\n      storeKeyFragment: {\n        fragmentValue: uint8arrayFromString(val)\n      },\n      authSig: uint8arrayFromString(JSON.stringify(authSig)),\n      tokenParams: {\n        tokenAddress: uint8arrayFromString(tokenAddress),\n        tokenId: uint8arrayFromString(tokenId.toString()),\n        chain: uint8arrayFromString(chain)\n      }\n    })\n    return await this.sendCommandToPeer({ peerId, data })\n  }\n\n  async getDataFromNode ({ peerId, tokenAddress, tokenId, keyId, authSig, chain }) {\n    console.debug(`getDataFromNode ${peerId} with keyId ${keyId}`)\n    const data = Request.encode({\n      type: Request.Type.GET_KEY_FRAGMENT,\n      getKeyFragment: {\n        keyId: uint8arrayFromString(keyId)\n      },\n      authSig: uint8arrayFromString(JSON.stringify(authSig)),\n      tokenParams: {\n        tokenAddress: uint8arrayFromString(tokenAddress),\n        tokenId: uint8arrayFromString(tokenId.toString()),\n        chain: uint8arrayFromString(chain)\n      }\n    })\n    return await this.sendCommandToPeer({ peerId, data })\n  }\n\n  async sendCommandToPeer ({ peerId, data }) {\n    const connection = this.libp2p.connectionManager.get(PeerId.createFromB58String(peerId))\n    const { stream } = await connection.newStream(['/lit/1.0.0'])\n    console.debug(`sendCommandToPeer ${peerId}`)\n    let retVal = null\n    await pipe(\n      [data],\n      stream,\n      async function (source) {\n        console.debug('in sendCommandToPeer callback')\n        const { value, done } = await source.next()\n        console.debug('got value from source.next()', value)\n        const resp = Response.decode(value.slice())\n        if (resp.type === Response.Type.STORE_KEY_FRAGMENT_RESPONSE) {\n          if (resp.storeKeyFragmentResponse.result === StoreKeyFragmentResponse.Result.SUCCESS) {\n            console.log('success storing key fragment')\n            retVal = true\n          } else {\n            console.log('error storing key fragment: ')\n            console.log(uint8arrayToString(resp.storeKeyFragmentResponse.errorMessage))\n            retVal = false\n          }\n        } else if (resp.type === Response.Type.GET_KEY_FRAGMENT_RESPONSE) {\n          if (resp.getKeyFragmentResponse.result === GetKeyFragmentResponse.Result.SUCCESS) {\n            console.log('success getting key fragment')\n            retVal = uint8arrayToString(resp.getKeyFragmentResponse.fragmentValue)\n          } else if (resp.getKeyFragmentResponse.result === GetKeyFragmentResponse.Result.NOT_FOUND) {\n            console.log('key fragment not found')\n            retVal = false\n          } else {\n            console.log('unknown error getting key fragment')\n            retVal = false\n          }\n        } else {\n          console.log('unknown response type')\n        }\n      }\n    )\n    return retVal\n  }\n\n  async connect () {\n    const hardcodedPeerId = '12D3KooWK1KtaAV5rWjbAmZcd62VYSmEz1k81jzr87JAcSS7rKdQ'\n    // Create our libp2p node\n    this.libp2p = await Libp2p.create({\n      modules: {\n        transport: [Websockets, WebRTCDirect],\n        connEncryption: [NOISE],\n        streamMuxer: [Mplex],\n        dht: KadDHT,\n        peerDiscovery: [Bootstrap]\n      },\n      config: {\n        dht: {\n          enabled: true\n        },\n        peerDiscovery: {\n          [Bootstrap.tag]: {\n            enabled: true,\n            list: [`/ip4/127.0.0.1/tcp/9090/http/p2p-webrtc-direct/p2p/${hardcodedPeerId}`]\n          }\n        }\n      }\n    })\n\n    // Listen for new peers\n    this.libp2p.on('peer:discovery', (peerId) => {\n      console.debug(`Found peer ${peerId.toB58String()}`)\n    })\n\n    // Listen for new connections to peers\n    this.libp2p.connectionManager.on('peer:connect', async (connection) => {\n      const peerId = connection.remotePeer.toB58String()\n      console.debug(`Connected to ${peerId}`)\n      if (this.connectedNodes.has(peerId)) {\n        return\n      }\n      this.connectedNodes.add(peerId)\n    })\n\n    // Listen for peers disconnecting\n    this.libp2p.connectionManager.on('peer:disconnect', (connection) => {\n      const peerId = connection.remotePeer.toB58String()\n      console.debug(`Disconnected from ${peerId}`)\n      this.connectedNodes.delete(peerId)\n    })\n\n    await this.libp2p.start()\n    console.debug(`libp2p id is ${this.libp2p.peerId.toB58String()}`)\n    this.libp2p.multiaddrs.forEach((ma) => console.debug(`${ma.toString()}/p2p/${this.libp2p.peerId.toB58String()}`))\n\n    // Export libp2p to the window so you can play with the API\n    window.libp2p = this.libp2p\n    window.PeerId = PeerId\n    // const hashed = multihashing(Buffer.from('1'), 'sha2-256')\n    // window.cid = new CID(hashed)\n\n    // const node1PeerId = PeerId.createFromB58String('QmXQtURimWjx8ihhWp1jjMv3rnv8xzq1qwY6KSzMr8dSGL')\n    // const ma = multiaddr('/ip4/127.0.0.1/tcp/9092/ws/p2p')\n    // libp2p.peerStore.addressBook.set(node1PeerId, [ma])\n  }\n}\n","import {\n  zipAndEncryptString,\n  zipAndEncryptFiles,\n  encryptZip,\n  decryptZip,\n  createHtmlLIT,\n  toggleLock\n} from './utils/lit'\n\nimport {\n  connectWeb3,\n  mintLIT,\n  checkAndSignAuthMessage\n} from './utils/eth'\n\nimport { LIT_CHAINS, protobufs } from './lib/constants'\nimport { kFragKey } from './lib/utils'\n\nimport LitNodeClient from './utils/lit-node-client'\n\nimport {\n  getUploadUrl,\n  createTokenMetadata\n} from './utils/cloudFunctions'\n\nconst functions = {\n  zipAndEncryptString,\n  zipAndEncryptFiles,\n  encryptZip,\n  decryptZip,\n  connectWeb3,\n  checkAndSignAuthMessage,\n  createHtmlLIT,\n  mintLIT,\n  toggleLock,\n  LIT_CHAINS,\n  LitNodeClient,\n  getUploadUrl,\n  createTokenMetadata,\n  protobufs,\n  kFragKey\n}\n\nexport default functions\n","import firebase from './firebase'\n\nexport async function savePublicKey (data) {\n  const fn = firebase.functions().httpsCallable('savePublicKey')\n  const result = await fn(data)\n  console.log(result)\n  return result.data\n}\n\nexport async function getPublicKey (data) {\n  const fn = firebase.functions().httpsCallable('getPublicKey')\n  const result = await fn(data)\n  console.log(result)\n  return result.data\n}\n\nexport async function getUploadUrl () {\n  const fn = firebase.functions().httpsCallable('getUploadUrl')\n  const result = await fn()\n  console.log(result)\n  return result.data\n}\n\nexport async function createTokenMetadata (data) {\n  const fn = firebase.functions().httpsCallable('createTokenMetadata')\n  const result = await fn(data)\n  console.log(result)\n  return result.data\n}\n"],"names":["SYMM_KEY_ALGO_PARAMS","name","length","PACKAGE_CACHE","decryptZip","encryptedZipBlob","symmKey","importedSymmKey","jwkSymmKey","crypto","subtle","importKey","JSON","parse","importSymmetricKey","decryptedZipArrayBuffer","encryptedBlob","recoveredIv","slice","arrayBuffer","encryptedZipArrayBuffer","decrypt","iv","decryptWithSymmetricKey","zip","JSZip","loadAsync","files","encryptZip","zipBlob","generateAsync","type","zipBlobArrayBuffer","console","log","generateKey","generateSymmetricKey","data","window","getRandomValues","Uint8Array","encryptedZipData","encrypt","Blob","encryptWithSymmetricKey","exportedSymmKey","exportKey","symmetricKey","encryptedZip","async","getNpmPackage","packageName","resp","fetch","ok","Error","statusText","blob","dataUrl","file","Promise","resolve","reject","reader","FileReader","onloadend","result","readAsDataURL","firebase","initializeApp","apiKey","authDomain","projectId","storageBucket","messagingSenderId","appId","measurementId","protobufs","require","protons","LIT_CHAINS","polygon","contractAddress","chainId","ethereum","connectWeb3","errorCode","message","provider","detectEthereumProvider","account","request","method","toLowerCase","web3","Web3","checkAndSignAuthMessage","authSig","localStorage","getItem","signAndSaveAuthMessage","address","now","Date","toISOString","body","replace","signedResult","signature","eth","personal","sign","accounts","recover","msg","error","alert","signMessage","setItem","stringify","sig","derivedVia","signedMessage","kFragKey","tokenAddress","tokenId","chain","normalizedTokenAddress","normalizedTokenId","toString","padStart","hashed","multihashing","Buffer","from","CID","Request","Response","StoreKeyFragmentResponse","GetKeyFragmentResponse","functions","zipAndEncryptString","string","zipAndEncryptFiles","i","folder","createHtmlLIT","title","htmlBody","css","encryptedSymmetricKey","encryptedZipDataUrl","npmPackages","push","scriptTags","mintLIT","quantity","getChainId","contract","Contract","LIT","txReceipt","methods","mint","send","txHash","transactionHash","events","TransferSingle","returnValues","id","mintingAddress","code","toggleLock","mediaGridHolder","document","getElementById","lockedHeader","locked","publicContent","innerHTML","decryptedFiles","mediaGridHtmlBody","innerText","LitNodeClient","constructor","config","this","libp2p","connectedNodes","Set","[object Object]","nodes","Array","numShares","threshold","Math","floor","secret","debug","kFrags","secrets","share","storagePromises","storeDataWithNode","peerId","val","all","success","keyId","cid","providers","contentRouting","findProviders","timeout","kFragPromises","toB58String","getDataFromNode","encode","Type","STORE_KEY_FRAGMENT","storeKeyFragment","fragmentValue","uint8arrayFromString","tokenParams","sendCommandToPeer","GET_KEY_FRAGMENT","getKeyFragment","connection","connectionManager","get","PeerId","createFromB58String","stream","newStream","retVal","pipe","source","value","next","decode","STORE_KEY_FRAGMENT_RESPONSE","storeKeyFragmentResponse","Result","SUCCESS","uint8arrayToString","errorMessage","GET_KEY_FRAGMENT_RESPONSE","getKeyFragmentResponse","NOT_FOUND","Libp2p","create","modules","transport","Websockets","WebRTCDirect","connEncryption","NOISE","streamMuxer","Mplex","dht","KadDHT","peerDiscovery","Bootstrap","enabled","tag","list","on","remotePeer","_this","has","add","delete","start","multiaddrs","forEach","ma","getUploadUrl","fn","httpsCallable","createTokenMetadata"],"mappings":"8qBAIA,MAAMA,EAAuB,CAC3BC,KAAM,UACNC,OAAQ,KCWJC,EAAgB,kBAiBAC,EAAYC,EAAkBC,GAelD,MAAMC,uBD9BkCC,GAQxC,aAP8BC,OAAOC,OAAOC,UAC1C,MACAC,KAAKC,MAAML,GACXR,GACA,EACA,CAAC,UAAW,YCwBgBc,CAAmBR,GAE3CS,uBDZNC,EACAV,GAEA,MAAMW,QAAoBD,EAAcE,MAAM,EAAG,IAAIC,cAC/CC,QAAgCJ,EAAcE,MAAM,IAAIC,cAS9D,aAR2BV,OAAOC,OAAOW,QACvC,CACEpB,KAAM,UACNqB,GAAIL,GAENX,EACAc,GCCoCG,CACpClB,EACAE,GAIIiB,EAAM,IAAIC,EAahB,aAZuBD,EAAIE,UAAUX,IAYrBY,qBAGIC,EAAYJ,GAChC,MAAMK,QAAgBL,EAAIM,cAAc,CAAEC,KAAM,SAC1CC,QAA2BH,EAAQV,cACzCc,QAAQC,IAAI,OAAQL,GAEpB,MAAMvB,yBD3CN,aALsBG,OAAOC,OAAOyB,YAClCnC,GACA,EACA,CAAC,UAAW,YC6CQoC,GAChB/B,uBDrBNC,EACA+B,GAGA,MAAMf,EAAKgB,OAAO7B,OAAO8B,gBAAgB,IAAIC,WAAW,KAElDC,QAAyBhC,OAAOC,OAAOgC,QAC3C,CACEzC,KAAM,UACNqB,GAAAA,GAEFhB,EACA+B,GAGF,OADyB,IAAIM,KAAK,CAACrB,EAAI,IAAIkB,WAAWC,IAAoB,CAAEV,KAAM,6BCOnDa,CAC7BtC,EACA0B,GAMIa,QAAwBpC,OAAOC,OAAOoC,UAAU,MAAOxC,GA+C7D,OA9CA2B,QAAQC,IAAI,kBAAmBW,GA8CxB,CACLE,aAAcF,EACdG,aAAc3C,GAIlB4C,eAAeC,EAAeC,GAE5B,GAAIhD,EAAcgD,GAEhB,OAAOhD,EAAcgD,GAGvB,MAAMC,QAAaC,MAAM,qBAAuBF,GAChD,IAAKC,EAAKE,GAER,MADArB,QAAQC,IAAI,wBAAyBkB,GAC/BG,MAAMH,EAAKI,YAEnB,MAAMC,QAAaL,EAAKK,OAElBC,QC1JuBC,ED0JOF,MCzJzBG,QAAQ,CAACC,EAASC,KAC3B,MAAMC,EAAS,IAAIC,WACnBD,EAAOE,UAAY,KACjBJ,EAAQE,EAAOG,SAEjBH,EAAOI,cAAcR,UANMA,ED6J7B,OADAxD,EAAcgD,GAAeO,EACtBA,EE/ITU,EAASC,cAXc,CACrBC,OAAQ,0CACRC,WAAY,0BACZC,UAAW,UACXC,cAAe,sBACfC,kBAAmB,gBACnBC,MAAO,6CACPC,cAAe,u4KCVjB,MAEaC,EAFGC,QAAQ,UAECC,CAAS,ksCAqDrBC,EAAa,CACxBC,QAAS,CACPC,gBAAiB,6CACjBC,QAAS,KAEXC,SAAU,CACRF,gBAAiB,6CACjBC,QAAS,mBChCSE,IACpB,QAA+B,IAApB/C,OAAO8C,SAChB,UAAU7B,MAAM,CAAE+B,UAAW,YAAaC,QAAS,6BAGrD,MAAMC,QAAiBC,IAIjBC,SADiBF,EAASG,QAAQ,CAAEC,OAAQ,yBACzB,GAAGC,cAG5B,MAAO,CAAEC,KADI,IAAIC,EAAKP,GACPE,QAAAA,kBAGKM,IACpB,IAAIC,EAAUC,aAAaC,QAAQ,sBAC9BF,UACGG,IACNH,EAAUC,aAAaC,QAAQ,uBAEjCF,EAAUrF,KAAKC,MAAMoF,GACrB,MAAMP,QAAQA,SAAkBL,IAOhC,OALIK,IAAYO,EAAQI,gBAChBD,IACNH,EAAUC,aAAaC,QAAQ,sBAC/BF,EAAUrF,KAAKC,MAAMoF,IAEhBA,iBAGaG,IACpB,MAAME,GAAO,IAAIC,MAAQC,cACnBC,EArDoB,wDAqDOC,QAAQ,gBAAiBJ,GACpDK,wBAS2BF,KAAEA,IACnC,MAAMX,KAAEA,EAAFJ,QAAQA,SAAkBL,IAEhCpD,QAAQC,IAAI,gBAAiBwD,GAC7B,MAAMkB,QAAkBd,EAAKe,IAAIC,SAASC,KAAKN,EAAMf,GAC/CW,EAAUP,EAAKe,IAAIG,SAASC,QAAQR,EAAMG,GAAWf,cAK3D,GAHA5D,QAAQC,IAAI,cAAe0E,GAC3B3E,QAAQC,IAAI,sBAAuBmE,GAE/BA,IAAYX,EAAS,CACvB,MAAMwB,EAAO,sDAAqDb,oCAA2CX,oCAG7G,MAFAzD,QAAQkF,MAAMD,GACdE,MAAM,uLACI7D,MAAM2D,GAGlB,MAAO,CAAEN,UAAAA,EAAWP,QAAAA,GA1BOgB,CAAY,CAAEZ,KAAAA,IACzCP,aAAaoB,QAAQ,qBAAsB1G,KAAK2G,UAAU,CACxDC,IAAKb,EAAaC,UAClBa,WAAY,yBACZC,cAAejB,EACfJ,QAASM,EAAaN,iBCnEbsB,EAAW,EAAGC,aAAAA,EAAcC,QAAAA,EAASC,MAAAA,MAChD,MAAMC,EAAyBH,EAAa/B,cACtCmC,EAAoBH,EAAQI,SAAS,IAAIC,SAAS,GAAI,KAEtDC,EAASC,EAAaC,OAAOC,KADb,GAAEP,KAA0BC,KAAqBF,KAChB,YAEvD,OADY,IAAIS,EAAIJ,GACTF,aCaPO,QAAEA,EAAFC,SAAWA,EAAXC,yBAAqBA,EAArBC,uBAA+CA,GAA2B9D,ECG1E+D,EAAY,CAChBC,mCPPyCC,GACzC,MAAMtH,EAAM,IAAIC,EAEhB,OADAD,EAAImC,KAAK,aAAcmF,GAChBlH,EAAWJ,IOKlBuH,kCPFwCpH,GAExC,MAAMH,EAAM,IAAIC,EAChB,IAAK,IAAIuH,EAAI,EAAGA,EAAIrH,EAAMzB,OAAQ8I,IAChCxH,EAAIyH,OAAO,mBAAmBtF,KAAKhC,EAAMqH,GAAG/I,KAAM0B,EAAMqH,IAE1D,OAAOpH,EAAWJ,IOHlBI,WAAAA,EACAxB,WAAAA,EACAiF,YAAAA,EACAW,wBAAAA,EACAkD,8BPgImCC,MACnCA,EADmCC,SAEnCA,EAFmCC,IAGnCA,EAHmCC,sBAInCA,EAJmCC,oBAKnCA,EALmCC,YAMnCA,EAAc,KAEdA,EAAYC,KAAK,cAEjB,IAAIC,EAAa,GACjB,IAAK,IAAIV,EAAI,EAAGA,EAAIQ,EAAYtJ,OAAQ8I,IAGtCU,GADa,sBADexG,EAAcsG,EAAYR,oBAOxD,MAAQ,mDAIGG,8CACqBE,kBAC5BK,sDAE8BJ,uCACDC,wFAKdH,gOOhKnBO,wBH8J6B7B,MAAEA,EAAF8B,SAASA,IACtC3H,QAAQC,IAAK,WAAU0H,eAAsB9B,KAC7C,MAAM7B,QAAgBD,KAChBF,KAAEA,EAAFJ,QAAQA,SAAkBL,IAEhC,SADsBS,EAAKe,IAAIgD,eACf7E,EAAW8C,GAAO3C,QAChC,MAAO,CAAEG,UAAW,eAEtB,MAAMsC,EAAe5C,EAAW8C,GAAO5C,gBACjC4E,EAAW,IAAIhE,EAAKe,IAAIkD,SAASC,EAASpC,GAChD3F,QAAQC,IAAI,uBACZ,IACE,MAAM+H,QAAkBH,EAASI,QAAQC,KAAKP,GAAUQ,KAAK,CAAE9B,KAAM5C,IAGrE,OAFAzD,QAAQC,IAAI,cAAe+H,GAEpB,CACLI,OAAQJ,EAAUK,gBAClBzC,QAHcoC,EAAUM,OAAOC,eAAeC,aAAaC,GAI3D9C,aAAAA,EACA+C,eAAgBjF,EAChBO,QAAAA,GAEF,MAAOkB,GAEP,OADAlF,QAAQC,IAAIiF,GACO,OAAfA,EAAMyD,MAER3I,QAAQC,IAAI,yBACL,CAAEoD,UAAW,2BAEpBrD,QAAQkF,MAAMA,GAET,CAAE7B,UAAW,oBG5LtBuF,4BP4KA,MAAMC,EAAkBC,SAASC,eAAe,mBAC1CC,EAAeF,SAASC,eAAe,gBAE7C,GAAI1I,OAAO4I,OAAQ,CAGjB5I,OAAO6I,cAAgBL,EAAgBM,UAEvC,MAAM/K,cAAgCgD,MAAMf,OAAOiH,sBAAsB9F,OACnE4H,QAAuBjL,EAAWC,EAAkBO,KAAK2G,UAAUjF,OAAOgH,wBAC1EgC,QAA0BD,EAAe,cAAcpI,MAAM,QACnE6H,EAAgBM,UAAYE,EAC5BL,EAAaM,UAAY,WACzBjJ,OAAO4I,QAAS,OAEhBJ,EAAgBM,UAAY9I,OAAO6I,cACnCF,EAAaM,UAAY,SACzBjJ,OAAO4I,QAAS,GO5LlBlG,WAAAA,EACAwG,oBDXAC,YAAaC,GACXC,KAAKC,OAAS,KACdD,KAAKE,eAAiB,IAAIC,IAGLC,yBAAEnE,aAAEA,EAAFC,QAAgBA,EAAhB9E,aAAyBA,EAAzBkD,QAAuCA,EAAvC6B,MAAgDA,IACvE,MAAMkE,EAAQC,MAAM3D,KAAKqD,KAAKE,gBAExBK,EAAYF,EAAM9L,OAClBiM,EAAYC,KAAKC,MAAMH,EAAY,GAEnCI,EAASjE,OAAOC,KAAKvF,GAAckF,SAAS,OAClDhG,QAAQsK,MAAO,qBAAoBL,gCAAwCC,KAC3E,MAAMK,EAASC,EAAQC,MAAMJ,EAAQJ,EAAWC,GAChD,GAAIK,EAAOtM,SAAW8L,EAAM9L,OAC1B,UAAUqD,MAAO,kBAAiBiJ,EAAOtM,6BAA6B8L,EAAM9L,WAE9E,MAAMyM,EAAkB,GAClB5E,EAAyBH,EAAa/B,cAC5C,IAAK,IAAImD,EAAI,EAAGA,EAAIgD,EAAM9L,OAAQ8I,IAChC/G,QAAQsK,MAAO,yBAAwBvD,EAAI,QAAQgD,EAAM9L,UACzDyM,EAAgBlD,KACdkC,KAAKiB,kBAAkB,CACrBC,OAAQb,EAAMhD,GACdpB,aAAcG,EACdF,QAAAA,EACAiF,IAAKN,EAAOxD,GACZ/C,QAAAA,EACA6B,MAAAA,KAMN,aAFMlE,QAAQmJ,IAAIJ,GAClB1K,QAAQC,IAAI,cACL,CAAE8K,SAAS,GAGWjB,iCAAEnE,aAAEA,EAAFC,QAAgBA,EAAhB5B,QAAyBA,EAAzB6B,MAAkCA,IAEjE,MAAMC,EAAyBH,EAAa/B,cACtCoH,EAAQtF,EAAS,CAAEC,aAAAA,EAAcC,QAAAA,EAASC,MAAAA,IAC1CoF,EAAM,IAAI3E,EAAI0E,GACdE,QAAkBJ,EAAIpB,KAAKC,OAAOwB,eAAeC,cAAcH,EAAK,CAAEI,QAAS,OACrFrL,QAAQC,IAAK,SAAQiL,EAAUjN,oBAC/B,MAAMqN,EAAgB,GACtB,IAAK,IAAIvE,EAAI,EAAGA,EAAImE,EAAUjN,OAAQ8I,IAAK,CACzC,MAAM6D,EAASM,EAAUnE,GAAG0B,GAAG8C,cAC/BvL,QAAQsK,MAAO,WAAUU,UAAcJ,KACvCU,EAAc9D,KAAKkC,KAAK8B,gBAAgB,CACtCZ,OAAAA,EACAjF,aAAcG,EACdF,QAAAA,EACA5B,QAAAA,EACAgH,MAAAA,EACAnF,MAAAA,KAIJ,aADqBlE,QAAQmJ,IAAIQ,GAIZxB,yBAAEc,OAAEA,EAAFjF,aAAUA,EAAVC,QAAwBA,EAAxBiF,IAAiCA,EAAjC7G,QAAsCA,EAAtC6B,MAA+CA,IACtE7F,QAAQsK,MAAO,0BAAyBM,uBAA4BjF,iBAA4BC,KAChG,MAAMxF,EAAOmG,EAAQkF,OAAO,CAC1B3L,KAAMyG,EAAQmF,KAAKC,mBACnBC,iBAAkB,CAChBC,cAAeC,EAAqBjB,IAEtC7G,QAAS8H,EAAqBnN,KAAK2G,UAAUtB,IAC7C+H,YAAa,CACXpG,aAAcmG,EAAqBnG,GACnCC,QAASkG,EAAqBlG,EAAQI,YACtCH,MAAOiG,EAAqBjG,MAGhC,kBAAkBmG,kBAAkB,CAAEpB,OAAAA,EAAQxK,KAAAA,IAG3B0J,uBAAEc,OAAEA,EAAFjF,aAAUA,EAAVC,QAAwBA,EAAxBoF,MAAiCA,EAAjChH,QAAwCA,EAAxC6B,MAAiDA,IACtE7F,QAAQsK,MAAO,mBAAkBM,gBAAqBI,KACtD,MAAM5K,EAAOmG,EAAQkF,OAAO,CAC1B3L,KAAMyG,EAAQmF,KAAKO,iBACnBC,eAAgB,CACdlB,MAAOc,EAAqBd,IAE9BhH,QAAS8H,EAAqBnN,KAAK2G,UAAUtB,IAC7C+H,YAAa,CACXpG,aAAcmG,EAAqBnG,GACnCC,QAASkG,EAAqBlG,EAAQI,YACtCH,MAAOiG,EAAqBjG,MAGhC,kBAAkBmG,kBAAkB,CAAEpB,OAAAA,EAAQxK,KAAAA,IAGzB0J,yBAAEc,OAAEA,EAAFxK,KAAUA,IACjC,MAAM+L,EAAazC,KAAKC,OAAOyC,kBAAkBC,IAAIC,EAAOC,oBAAoB3B,KAC1E4B,OAAEA,SAAiBL,EAAWM,UAAU,CAAC,eAC/CzM,QAAQsK,MAAO,qBAAoBM,KACnC,IAAI8B,EAAS,KAkCb,aAjCMC,EACJ,CAACvM,GACDoM,EACAxL,eAAgB4L,GACd5M,QAAQsK,MAAM,iCACd,MAAMuC,MAAEA,SAAsBD,EAAOE,OACrC9M,QAAQsK,MAAM,+BAAgCuC,GAC9C,MAAM1L,EAAOqF,EAASuG,OAAOF,EAAM5N,SAC/BkC,EAAKrB,OAAS0G,EAASkF,KAAKsB,4BAC1B7L,EAAK8L,yBAAyBhL,SAAWwE,EAAyByG,OAAOC,SAC3EnN,QAAQC,IAAI,gCACZyM,GAAS,IAET1M,QAAQC,IAAI,gCACZD,QAAQC,IAAImN,EAAmBjM,EAAK8L,yBAAyBI,eAC7DX,GAAS,GAEFvL,EAAKrB,OAAS0G,EAASkF,KAAK4B,0BACjCnM,EAAKoM,uBAAuBtL,SAAWyE,EAAuBwG,OAAOC,SACvEnN,QAAQC,IAAI,gCACZyM,EAASU,EAAmBjM,EAAKoM,uBAAuB1B,gBAC/C1K,EAAKoM,uBAAuBtL,SAAWyE,EAAuBwG,OAAOM,WAC9ExN,QAAQC,IAAI,0BACZyM,GAAS,IAET1M,QAAQC,IAAI,sCACZyM,GAAS,GAGX1M,QAAQC,IAAI,2BAIXyM,EAGI5C,2BAGXJ,KAAKC,aAAe8D,EAAOC,OAAO,CAChCC,QAAS,CACPC,UAAW,CAACC,EAAYC,GACxBC,eAAgB,CAACC,GACjBC,YAAa,CAACC,GACdC,IAAKC,EACLC,cAAe,CAACC,IAElB7E,OAAQ,CACN0E,IAAK,CACHI,SAAS,GAEXF,cAAe,CACbvE,CAACwE,EAAUE,KAAM,CACfD,SAAS,EACTE,KAAM,CAAE,gHAOhB/E,KAAKC,OAAO+E,GAAG,iBAAmB9D,IAChC5K,QAAQsK,MAAO,cAAaM,EAAOW,mBAIrC7B,KAAKC,OAAOyC,kBAAkBsC,GAAG,eAAgB1N,eAAOmL,GACtD,MAAMvB,EAASuB,EAAWwC,WAAWpD,cACrCvL,QAAQsK,MAAO,gBAAeM,KAC1BgE,EAAKhF,eAAeiF,IAAIjE,IAG5BgE,EAAKhF,eAAekF,IAAIlE,KAI1BlB,KAAKC,OAAOyC,kBAAkBsC,GAAG,kBAAoBvC,IACnD,MAAMvB,EAASuB,EAAWwC,WAAWpD,cACrCvL,QAAQsK,MAAO,qBAAoBM,KACnClB,KAAKE,eAAemF,OAAOnE,gBAGlBjB,OAAOqF,QAClBhP,QAAQsK,MAAO,gBAAeZ,KAAKC,OAAOiB,OAAOW,iBACjD7B,KAAKC,OAAOsF,WAAWC,QAASC,GAAOnP,QAAQsK,MAAO,GAAE6E,EAAGnJ,kBAAkB0D,KAAKC,OAAOiB,OAAOW,kBAGhGlL,OAAOsJ,OAASD,KAAKC,OACrBtJ,OAAOiM,OAASA,IChLlB8C,8BCpBA,MAAMC,EAAKlN,EAASwE,YAAY2I,cAAc,gBACxCrN,QAAeoN,IAErB,OADArP,QAAQC,IAAIgC,GACLA,EAAO7B,MDkBdmP,mCCfyCnP,GACzC,MAAMiP,EAAKlN,EAASwE,YAAY2I,cAAc,uBACxCrN,QAAeoN,EAAGjP,GAExB,OADAJ,QAAQC,IAAIgC,GACLA,EAAO7B,MDYdwC,UAAAA,EACA8C,SAAAA"}